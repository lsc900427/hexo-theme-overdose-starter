{"meta":{"title":"<= 쉽게 읽히는","subtitle":null,"description":null,"author":"SangCheol Lee","url":"https://lsc900427.github.io"},"pages":[{"title":"테스트","date":"2017-08-02T20:29:47.000Z","updated":"2017-08-02T20:29:22.000Z","comments":true,"path":"about/index.html","permalink":"https://lsc900427.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"git-02","slug":"git-02","date":"2017-10-01T03:49:03.000Z","updated":"2017-10-01T03:49:03.000Z","comments":true,"path":"2017/10/01/git-02/","link":"","permalink":"https://lsc900427.github.io/2017/10/01/git-02/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"git-01","slug":"git-01","date":"2017-09-23T01:18:52.000Z","updated":"2017-09-23T03:45:25.000Z","comments":true,"path":"2017/09/23/git-01/","link":"","permalink":"https://lsc900427.github.io/2017/09/23/git-01/","excerpt":"","text":"버전관리가 무엇인가? 파일변화를 시간에 따라 기록했다가 이후에 특정 시점의 버전을 로드할 수 있는시스템 작업자들의 기록이 한 로그에 기록이 된다 효율적으로 로그를 관리하고 싶을때 버전관리를 사용한다. 왜 대세인가? 대세의 이유 오픈소스다 공개 프로젝트는 항상무료다. 비공개는 돈을 내야한다. 효율적으로 개발자와 개발자가 소통할 수 있다. 통째로 저장소에 저장 할 수 있다. fork란 기능을 통해서 독립된 공간에서 작업을 하고 개선할 수 있다. 그리고 제안도 할 수 있다.(포크를 받아서 복사를 한 후에 Pull request라는 기능을 통해서 제안을 할 수가 있다. ) branch를 이용한 local에서의 자유로운 실험이 가능하다. 변동사항이 없으면 깃은파일을 저장하지 않고이전상태 파일에 대한 링크만 저장한다. 커밋은 작업자 내용 시간 내용등을 전부 저장한다. git –version which git 전역과 지역의 차이 git config –global user.name 글로벌 옵션명령어만 빼면 지역에서 할 수 가 있다. git init을 한 후에 해야 한다. git init이란?? 로컬에서 저장소를 만든다. 로컬에서 만든 것과 원격으로 만든 것은 다르다. 로컬에서 저장소를 만들면 내 로컬에서만 만든거지 깃허브 페이지랑 연결된 것이 없다. 깃랩같은 것은 설치형 저장소(비공개 저장소나 사내용으로 사용하기 위한 기업용으로 많이 쓴다.) 기업용 깃랩은 무료다. 그러나 깃허브 상업적 사용은 비싸다. 웹에서 만들 수 도있다. 원격저장소로 만들기. git init으로 만들기.저장소와 연결을 해줘야하기 때문에 번거롭다 On branch masterYour branch is based on ‘origin/master’, but the upstream is gone. (use “git branch –unset-upstream” to fixup)nothing to commit, working tree cleanunmodified 수정되면 unmodified가 된다ㅡ 언트랙드 statge area에 올려야한다 깃은!!! 깃의 명령어 git status를 치는 습관이 필요하다 파일이 어떤 상태인지 꼭 알아야함 현재저상소의 변동이 있는지 없는지 확인할 수 있는 명령어다. 축약해서도 볼수 있다.. git status -s staging area 있는 이유 내가 원하는 것만 커밋을 하고 싶을때 staging area를 통해서 ! 개발 스테이징 개발 베포 리얼배포 충돌을 해결하고 싶을 때 master, 해시로그, 7글자 메세지 커밋생성 로그 이거고 메세지는 이거다. 4개의 파일변한거 확인가능 create mode 신규로 추가되었다. 깃이 돌아가는 과정을 상세히 볼 수 가 있다. [master 0d76dc0] hello 4 files changed, 188 insertions(+) create mode 100644 2.html create mode 100644 3.html create mode 100644 4.html create mode 100644 5.html git commit 이후에 메세지 위에 메세지를 입력해서 킬수도 있다. 유의미한 커밋메시지를 작성하도록 해라. 커밋을 하면 로그가 생긴다. 로그관리를 어떻게 하는지 알아야한다. 로그보는 것은 중요하다. git log git log –oneline 해시를 7글자로 줄여주고 커밋메세지만 보여준다. 만약 END가 나오면 Q로 빠져나온다. git log –graph -2 iTerm2","categories":[],"tags":[{"name":"git스터디","slug":"git스터디","permalink":"https://lsc900427.github.io/tags/git스터디/"}]},{"title":"Context","slug":"Context","date":"2017-09-17T23:26:44.000Z","updated":"2017-09-17T23:29:02.000Z","comments":true,"path":"2017/09/18/Context/","link":"","permalink":"https://lsc900427.github.io/2017/09/18/Context/","excerpt":"","text":"##실해컨텍스트란? 실행 가능한 코드 블럭이 실행되는 환경","categories":[],"tags":[]},{"title":"css-rendering3","slug":"css-rendering3","date":"2017-09-14T11:26:32.000Z","updated":"2017-09-14T11:35:35.000Z","comments":true,"path":"2017/09/14/css-rendering3/","link":"","permalink":"https://lsc900427.github.io/2017/09/14/css-rendering3/","excerpt":"","text":"css는 어떤 식으로 메모리상에 존재하는가- 선택자 잡아서 자바스크립트처럼 하는 것은 부하를 별로 주지 않는다","categories":[],"tags":[]},{"title":"css-rendersing2","slug":"css-rendersing2","date":"2017-09-07T11:02:30.000Z","updated":"2017-09-07T12:49:54.000Z","comments":true,"path":"2017/09/07/css-rendersing2/","link":"","permalink":"https://lsc900427.github.io/2017/09/07/css-rendersing2/","excerpt":"","text":"박스모델 css 레이아웃 규격을 지켜야한다 margin은 투명하다 그러나 실체는 있다 border는 외곽선(끝없는 크기를 가질 수 있다.) padding도 투명한다( 보더와 컨텐츠 박스를 띄워주는 역할 ) 하나의 엘리먼트는 4단계의 단계를 가지고 있다 width 100은 무엇이 100인거야? ms는 보더박스를 기준으로.. 그러나 ie는 컨텐츠박스 box -sizing 보더박스, 패딩박스, 컨텐츠박스 중 하나를 선택하자 지금까지 고정 박스 모델 확장된 css모듈은 그림에는 영향을 미치지 않지만 더 많은 효과를 줄 수 있는 효과들을 만들었다. Box-shadow -&gt; 무한히 만들 수 있다. Box-shadow inset OUTLINE -&gt; 박스쉐도우 위에 올릴 수 있다. Boxshaodw 노말 플로우 상에서 박스 쉐도우가 뒤에 나온 애가 이긴다. 노말 플로우 상태에서 rp를 사요하면 이기게된다. 부하를 주지 않는다. 지오메트리를 건드리지 않고 gpu로 칠하기 때문이다. 그러기에 앞으로 gpu가 칠해지는 것이 빠르기 때문에 잘 배워 써버리자. 지시 엘리먼트 @를 이용한 지시자 엘리먼트 키프레임 @폰트페이스 드레프트 규격은 머냐 원래 css에 없는 거지만 이제부터 이 규약을 쓰겠다 그것이 바로 지시자 엘리먼트다. 변화를 키프레임이라고 한다. 키프레임이 여러개 있어서 키프레임스다. 셀렉터는 각각 디렉티브내에서 다르게 작동한다. 디렉티브 별로 셀렉터가 다르게 나올 것이다. from하고 to라는 셀렉터를 이용해서 박스 쉐도우애니메이션 속성 Position fixed caret position &amp; offset offset이란 정확히 어떤 기준이 있는데 그 기준으로 부터 얼만큼 차이가 나는가? 기준을 알아야한다. 기준으로부터 상대적으로 얼만큼 떨어지냐. 왜 쓰냐 ? 분할하고 사용자가 부분적으로 이해하기 위해서 사용한다. 컨테이너에서 10만큼 떨어져있다. 즉 기준점을 향해서 얼만큼 떨어져 있냐? 절대적 기준이 아니라 기준으로 부터 얼만큼 쓰겠다는 걸 계산하겠다. 돔구조를 따르지 않고 노말 플ㄹ로우의 구조를 따라간다. 오프셋을 계산하는 방법은 오프셋 부모를 얻는 방법에 달려있다. 오프셋 부모 결정 법은? NULL ROOT, HTML, BODY POSITION: FIXED OUT OF DOM TREE NULL이 되면 전멸 RECURSIVE SEARCH PARENT.POSITION:FIXED = NULL PARENT.POSITION: !STATIC = OK BODY = OK TD, TH TABLE = OK DISPLAY 속성이 아니라 태그가 나와야한다. PARENT.PARENT CONTINUE 오프셋 부모를 얻으면 계산할 수 있다. offsetLeft offsetTopcss가 다 그림을 그리면 엘리먼트에 다 박아준다 오프셋정보들을 우리가 하는게 아니라 css렌더링 엔진이 해준다그렇기 때문에 offset 값을 바꿔도 안변한다 css렌더링 결과를 보여주고 있는 중일 뿐이다.리플로우를 모아서 한다 한프레임당의 변화를 모아서 한다한번할때마다가 아니라 묶어서 계산하는 것이다 한번에 변화를 묵어서그러나 코드 중간에 offset이 나오면 모으지 않고 그 순간 바로 리플로우를한다.offset 값을 쓰면 무조건 리플로우를 한다. 그렇기에 오프셋은 쓰지말고 오프셋쓸꺼면 전부 모아놔라 absolute 숫자를 안주면 기본값은 오프셋부모의 탑을 준다. left를 주면 부모에 맞춰진다","categories":[],"tags":[]},{"title":"css-Rendering","slug":"css-rendering1","date":"2017-08-31T11:30:46.000Z","updated":"2017-08-31T12:36:58.000Z","comments":true,"path":"2017/08/31/css-rendering1/","link":"","permalink":"https://lsc900427.github.io/2017/08/31/css-rendering1/","excerpt":"","text":"영역 나누기(GeoMetry Calculate) 현대의 렌더링은 geometry를 계산하고 Fragement를 한다 Geometry를 계산하는 과정을 reflow라 한다 width ,height, position칠하기(Fragment Fill) fragement는 픽셀 Fragment를 칠하는 과정을 repaint라 한다 background 현대의 시스템은 영역을 나누고 색을 칠하는 것이 기본이다부하는 fragment fill에서 많이 받는 것 같지만reflow의 변화가 일어나면 전부 다시그려야해서 부하를 더 많이 받는다.geomery쪽 표현을 이해하는 것이 더 어렵다색칠하는 쪽은 위에 비해 국소적인 표현이기 때문에 더 쉽다 CSS specifications본질은 약속이다~~ 하면 ~~ 해줘.과거에는 W3c 현재는 HTML재단에서 CSS LEVEL1 A4용지 한장 짜리 분량 CSS LEVEL2 + MODULE 통합레벨, 표현과 내용을 분리하자, CSS의 활성화 CSS 모듈을 쪼개서 관리할래 CSS LEVEL 2.1 통합레벨이 있다. 모듈들의 통합이라 거의레벨 3이라고 볼수 있다 Module level 레벨은 사라졌다 모듈이 계속 제안되고 있다. 새 모듈 태반이 초안이다 CSS 3 는 존재하지않는다. 2.1에서 튀어나온 것이다. 즉 모듈들이 개별적으로 발전하는 것이다.(너무 많은 모듈들이 중구난방으로 발전) NORMAL FLOW 공부는 정확한 용어를 정확하게 설명 왜그런지 말을 못하면 구현도 못한다(스펙 문서가 중요하다) -NORMAL FLOW가 핵심이다. 이걸 이해 못하면 HTML을 모른다. -POSITION static relative 위의 두가지만 노말플로우의 영향을 받음 Block Formatiing Context, inline Formatting Context, relative Position BFC, IFC, RP 노말 플로우의 핵심 BFC가 오프셋의 값을 계산해준다. 인라인 요소를 만나면 인라인 블락을 만든다 새로운 BFC를만드는 알고리즘 또한있다 많은 BFC가 모여서 그려진다. word-breaking을 걸어두면 글자하나하나를 span처럼 계산하는 구나 ifc의 알고리즘을 변경해준다. BFC, IFC가 중요하지 돔이 중욯지 않다 RP static으로 그리고나서 스태틱으로 그려진 위치에서 상대적으로 얼마 줄거냐 라는 것을 나타낸다 노말 플로를 계산하고 relative를 얼마를 주겠다라는 뜻이다. Float left, right, none, inherit css reset 속성은 속성별로 따로 외워야한다(다양한 모듈 때문에) NEW BFC -&gt; Float over Normal flow -&gt; Text, Inline Guard(ifc 요소의 가이드 ifc요소들이 float 요소의 자리에 못들어간다.) -&gt; Linebox(float은 line box의 개념으로 그려지게된다, ifc,bfc nomral flow로 그려지지 않는다.) 인라인 가드가 플로트 가드에 걸리면 부모의 크기를 확장시키지 않는다. 블락가드에걸리면 부모의 크기를 확장시킨다 플롯 가드에 걸리면 뒤를 안보고 내려버린다. 레프트 플롯가드보다 왼쪽 라이트 플롯가드보다 오른쪽에 있어야 한다. Overflow VISIBLE, HIDDEN, SCROLL, INHERIT, AUTO VISIBLE이 아닌 경우에 노말 플로우에 영향을 끼친다. 다른 걸 쓰면 NEW BFC를 만든다. 기본 값은 VISIBLE 자동으로 공간이 확장된다. BFC, IFC와 동일한 알고리즘을 가지는 것이라고 볼 수 있다. OverFLOW -X, -Y VISIBLE, HIDDEN, SCROLL, CLIP, AUTO 판단하는 모듈이 다른 css 모듈에 의존해야 한다 TEXT-OVERFLOW 2.1 ui module 표준안 CLIP, ELLIPSIS(…해주게하는거) - absolute - fixed - inherit","categories":[],"tags":[]},{"title":"Css-inheritance","slug":"Css-inheritance","date":"2017-08-06T20:19:04.000Z","updated":"2017-08-06T20:19:04.000Z","comments":true,"path":"2017/08/07/Css-inheritance/","link":"","permalink":"https://lsc900427.github.io/2017/08/07/Css-inheritance/","excerpt":"","text":"상속상속이란 상위 요소에 적용된 속성을 하위 요소가 물려받는 것을 의미한다상속 기능이 없다면 각 요소의 rule set에 속성을 매번 각각 지정해야한다.하지만 모든 속성이 상속되는 것이 아니다 상속이 되는 것과 되지 않는 것이 있다. 안되는 것들width, height, margin, padding, border, box-sizeingdisplay, background, vertical-align, text-decoration, position, top/right/bottom/left, z-index, overflow, float 되는 것들 visibility, opacity, font, color, line-height, text-align, white-space 또한 요소에 따라 상속받지 않는 경우도 존재한다. 이경우는 inherit 키워드를 사용하여 명시적으로 상속받게 할 수 있다. 캐스캐이딩요소는 하나 이상의 CSS선언에 영향을 받을 수 있따.이 때 충돌을 피하기 위해서 CSS 적용 우선순위가 필요한데 이를 캐스캐이딩이라고 한다. 중요도어디에 선언되었냐에 따라 우선순위가 달라진다 명시도대상을 명화갛게 특정할수록 선언 순서나중에 선언된 스타일이 우선 적용된다. CSS가 어디에 선언 되었는지에 따라서 우선순위가 달라진다. head 요소 내의 style 요소 head 요소 내의 style 요소 내의 @import문 link로 연결된 CSS파일 link로 연결된 CSS파일 내의 @import문 브라우저 디폴트 스타일 시트 transition transition: property duration function delay all 0 ease 0 -&gt; 초기값","categories":[],"tags":[]},{"title":"Css-BoxModel","slug":"Css-BoxModel","date":"2017-08-06T19:57:24.000Z","updated":"2017-08-06T19:57:24.000Z","comments":true,"path":"2017/08/07/Css-BoxModel/","link":"","permalink":"https://lsc900427.github.io/2017/08/07/Css-BoxModel/","excerpt":"","text":"브라우저는 박스모델의 크기와 프로퍼티 위치를 근거로 하여 렌더링을 실행한다. Contents : 요소의 텍스트나 이미지등의 실제 내용이 위치하는 영역 Padding : 보더 안쪽에 위치하는 요소의 내부 여백 영역 요소에 적용된 배경색 이미지는 패딩영역까지 적용된다. Border : 테두리 영역으로 보퍼 속성 값은 테두리의 두께를 의미한다. Margin : 테두리 바깥에 위치하는 요소의 외부 여백 영역이다. 컨텐츠가 width, height 값보다 크면 넘칠 수 있다넘치는 컨텐츠는 overflow:hidden을 통해서 감출 수 있다. block 레벨 요소 항상 새로운 라인에서 시작한다. 화면 크기 전체의 가로폭을 차지한다. width, height, amrgin, padding 프로퍼티 지정이 가능하다. block 레벨 요소 내에 inline 레벨 요소를 포함 할 수 있다. block 레벨 요소의 예 form, table inline 레벨 요소 새로운 라인에서 시작하지 않으면 문장의 중간에 들어갈 수 있다. 즉 줄을 바꾸지 않고 다른 요소와 함께 한 행에 위치한다 content의 너비만큼 가로 폭을 차지한다 width, height, amrgin, padding 프로퍼티 지정이 불가능하다 상 하 여백은 line-height로 지정한다. inline 레벨 요소 뒤에 공백이 있는 경우 정의하지 않은 space가 자동 지정된다. inline 레벨 요소 내에 block 레벨요소를 포함할 수 없다 inline레벨 요소는 일반적으로 block 레벨 요소에 포함되어 사용된다. textarea, button, select, img inline-block 레벨 요소 block과 inline 레벨 요소의 특징을 모두 갖는다. inline레벨 요소와 같이 한 줄에 표현되면서 width, height, margin 프로퍼티를 모두 지정 할 수 있다. 기본적으로 인라인 레벨 요소와 흡사하게 줄을 바꾸지 않고 다른 요소와 함께 한 행에 위치시킬 수 있따. 블락 처럼 가로, 세로, 마진 패딩 프로퍼티를 모두 정의하고 상하여백도 마진과 라이하이트 두가지 모두로 제어가능하다 visibility 프로퍼티요소를 보이게 할 것인지 보이지 않게 할 것이지 정의한다즉 요소의 렌더링 여부를 결정한다 visible 해당 요소를 보이게 한다 (기본값)hidden 해당 요소를 보이지 않게 한다. display: none;은 해당 요소의 공간까지 사라지게 하지만 visibility: hidden;은 해당 요소의 공간은 사라지지 않고 남아있게 된다.collapse table 요소에 사용하며 행이나 열을 보이지 않게 한다.none table 요소의 row나 column을 보이지 않게 한다. IE, 파이어폭스에서만 동작하며 크롬에서는 hidden과 동일하게 동작한다. position static 기본 값으로 기본적으로 position 프로퍼티를 지정하지 않을 때와 같다.부모 요소 내에 자식 요소로서 존재할 때는 부모 요소의 위치를 기준으로 배치된다.기본적으로 이 값을 지정할 일은 없지만 이미 설정된 position을 무력화 시키기위해서 사용된다. relative 기본 위치를 기준으로 좌표를 사용하여 위치를 이동시킨다static을 선언한 요소와 relative를 선언한 요소와의 차이는 좌표 프로퍼티의 동작여부뿐 absolute 부모 요소 혹은 가장 가까이 있는 조상요소 기준으로 좌표 프로퍼티 만큼 이동한다즉 static을 제외한 나머지 속성이 선언되어 있는 부모 또는 조상 요소를 기준으로 위치가 결정된다 static 일경우는 document body를 기준으로 하여 좌표 속성대로 위치하게된다.부모를 배치기준으로 삼고 싶다면 부모 요소에 relative를 정의해라absolute선언시 블락레벨 요소의 width는 인라인 요소처럼 content에 맞게 변화되므로적절한 width를 지정해야한다. floatfloat 속성은 해당요소를 다음 요소위에 떠있게한다. 플롯의 의미는 요소가 기본 레이아웃의 흐름에서 벗어나요소의 모서리가 페이지의 왼쪽이나 오른쪽으로 이동하는 것을 뜻한다.플롯 사용시 요소의 위치를 고정시키는 포지션 속성의 absolute를 사용하면 안된다. 플롯시 높이로 인한 문제 해결법12345.clearfix:after &#123; content: \"\"; display: block; clear: both;&#125;","categories":[],"tags":[]},{"title":"Html5-list,table","slug":"Html5-list-table","date":"2017-08-06T18:06:16.000Z","updated":"2017-08-06T18:06:16.000Z","comments":true,"path":"2017/08/07/Html5-list-table/","link":"","permalink":"https://lsc900427.github.io/2017/08/07/Html5-list-table/","excerpt":"","text":"목록순서없는 목록, 순서 있는 목록1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;h2&gt;순서없는 목록 (Unordered List)&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;Tea&lt;/li&gt; &lt;li&gt;Milk&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;h2&gt;순서있는 목록 (Ordered List)&lt;/h2&gt; &lt;ol&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;Tea&lt;/li&gt; &lt;li&gt;Milk&lt;/li&gt; &lt;/ol&gt; &lt;/body&gt;&lt;/html&gt; type 속성을 사용해서 순서를 나타내는 문자를 지정할 수 있다. “1” 숫자 (기본값) “A” 대문자 알파벳 “a” 소문자 알파벳 “I” 대문자 로마숫자 “i” 소문자 로마숫자12345&lt;ol type=\"I\"&gt; &lt;li value=\"2\"&gt;Coffee&lt;/li&gt; &lt;li value=\"4\"&gt;Tea&lt;/li&gt; &lt;li&gt;Milk&lt;/li&gt;&lt;/ol&gt; start 속성으로 리스트의 시작값을 지정할 수 있다. 12345&lt;ol start=\"3\"&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;Tea&lt;/li&gt; &lt;li&gt;Milk&lt;/li&gt;&lt;/ol&gt; reversed 속성은 리스트의 순서 값을 역으로 표현한다. 중첩목록12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;h2&gt;중첩 목록&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;Tea &lt;ol&gt; &lt;li&gt;Black tea&lt;/li&gt; &lt;li&gt;Green tea&lt;/li&gt; &lt;/ol&gt; &lt;/li&gt; &lt;li&gt;Milk&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 목록 태그는 네비게이션 메뉴를 만들 때 자주 사용된다. 테이블표를 만들 때 사용하는 태그이다 과거에는 테이블 태그를 사용하여 레이아웃을 구성하기도 했으나현대 웹에서는 주로 공간 분할 태그인 div 태그를 사용해 레이아웃을 구성한다 table : 표를 감싸는 태그 tr : 표 내부의 행 th : 행 내부의 제목 셀 td : 행 내부의 일반 셀 colspan : 행을 합칠때 rowspan : 열을 합칠 때 이미지 src : 이미지 파일 경로 alt : 이미지 파일이 없을 경우 표시되는 문장 width : 이미지의 너비 (CSS에서 지정하는 것이 일반적) height : 이미지의 높이 미디어audioaudio 태그는 HTML5에서 새롭게 추가된 태그다. src : 음악 파일경로 preload : 재생 전에 음악 파일을 모두 불러올 것인지 지정 autoplay: 음악 파일의 자동재생을 실행 할 것인지 지정 loop : 음악을 반복할 것인지 controls : 음악 재생도구를 표시할 것인지. source 태그를 사용해서 파일의 형식 차이 문제를 해결 할 수 있다. video src : 동영상 파일경로 poster : 동영상 준비중에 표시될 이미지 파일 경로 preload : 재생전 동영상 파일 모두 불러올 것인autoplay 동영상 파일을 자동의 재생 개시할 것인지 지정 loop 동영상을 반복할 것인지 지정 controls 동영상 재생 도구를 표시할 것인지 지정. 재생 도구의 외관은 브라우저마다 차이가 있다. width 동영상의 너비를 지정 height 동영상의 높이를 지정 form폼태그는 사용자가 입력한 데이터를 수집하기 위해 사용되며 input, textarea, button, select, checkbox, radio button, submit button 등의 입력 양식 태그를 포함 할 수 있다. action : URL을 값으로 입력 받음, 입력데이터가 전송될 URL을 지정 method : get / post, 입력데이터의 전달 방식을 지정 GET, POST는 HTTP 프로토콜을 이용해서 서버에 입력 데이터를 전달하는 방식이다. GET GET 방식은 전송 URL에 입력 데이터를 쿼리 스트링으로 보내는 방식 http://jsonplaceholder.typicode.com/posts?userId=1&amp;id=1 전송 URL 바로 뒤에 ?를 통해 데이터의 시작을 알려주고, key-value형태의 데이터를 추가한다. 1개 이상의 전송 데이터는 ‘&amp;’로 구분 URL에 전송 데이터가 모두 노출되기 때문에 보안에 문제가 있으며 전송할 수 있는 데이터의 한계가 있다.(255자) POST POST 방식은 Request Body에 담아 보내는 방식이다. http://jsonplaceholder.typicode.com/posts URL에 전송 데이터가 모두 노출되지 않지만 GET에 비해 속도가 느리다. inputinput태그는 폼태그 중에서 가장 중요한 태그로 사용자로부터 데이터를 입력받기 위해 사용된다.서버에 전송되는 데이터는 name 어트리뷰트를 키로 value 어트리뷰트를 값으로 하여 key = value의 형태로 전송된다. button : button create check box : checkbox create color : color select create date : date control create datetime : date &amp; time control create email : email input form create. file : file select form create hidden : hidden input form create image : image submit button create month : month select form create number : number input form create password : password input form create radio : radio button create range : rage select form create reset : reset button create search : search input form create submit : submit button create select복수개의 리스트에서 복수개의 아이템을 선택할때 사용한다서버에 전송되는 데이터는 select 요소의 name 어트리뷰트를 키로option 요소의 value 어트리뷰트를 값으로 하여 key = value의 형태로 전송한다.","categories":[],"tags":[]},{"title":"Html5-link","slug":"Html5-link","date":"2017-08-06T17:27:56.000Z","updated":"2017-08-06T17:27:56.000Z","comments":true,"path":"2017/08/07/Html5-link/","link":"","permalink":"https://lsc900427.github.io/2017/08/07/Html5-link/","excerpt":"","text":"정의HtperText의 Hyper는 컴퓨터 용어로써 텍스트 등의 정보가 동일 선상에 있는 것이 아니라다중으로 연결되어 있는 상태를 의미한다. 이것은 HTML의 가장 중요한 특징인 link의 개념과 연결되는데 기존 문서나 텍스트의 선형성 고정성의 제약에서 벗어나사용자가 원하는 순서대로 원하는 정보를 취득할 수 있는 기능을 제공한다.한 텍스트에서 다른 텍스트로 건너뛰어 읽을 수 있는 이 기능을 하이퍼링크라고 한다.HTML link는 hyperlink를 의미하며 atag가 그 역할을 담당한다. href 어트리뷰트href 어트리뷰트는 이동하고자 하는 파일의 위치(경로)를 값으로 받는다.경로(path)란 파일 시스템 상에서 특정 파일의 위치를 의미한다. 디렉토리디렉토리는 파일과 다른 디렉토리를 갖는 파일 시스템 내의 존재물로써 폴더라고 불리운다 루트 디렉토리 파일 시스템 계층 구조 상의 최상위 디렉토리 유닉스 : / 윈도우 : C:\\ 홈디렉토리 시스템의 사용자에게 각각 할당된 개별 디렉토리 유닉스: /users/계정명 윈도우: C:\\users\\계정명 작업 디렉토리 현재 작업 중인 파일의 위치한 디렉토리이다. ./ 부모 디렉토리 작업 디렉토리의 부모 디렉토리이다. ../ 파일 경로(File path)파일경로는 파일 시스템에서 파일의 위치를 나타내는 방법이다. 경로에는 절대경로와 상대경로가 있다. 절대경로 현재 작업디렉토리와 관련없이 특정 파일의 절대적인 위치를 가리킨다 루트 디렉토리를 기준으로 파일의 위치를 나타낸다. http://www.mysite.com/index.html /Users/leeungmo/Desktop/myImage.jpg C:\\users\\leeungmo\\Desktop\\myImage.jpg /index.html 상대경로 현재 작업디렉토리를 기준으로 특정파일의 상대적인 위치를 가리킨다. ./index.html ../dist/index.js ../../dist/index.js index.html html/index.html href 어트리뷰트에 사용 가능한 값은 아래와 같다. 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;a href=\"http://www.google.com\"&gt;URL&lt;/a&gt;&lt;br&gt; &lt;a href=\"html/my.html\"&gt;Local file&lt;/a&gt;&lt;br&gt; &lt;a href=\"file/my.pdf\" download&gt;Download file&lt;/a&gt;&lt;br&gt; &lt;a href=\"#\"&gt;fragment identifier&lt;/a&gt;&lt;br&gt; &lt;a href=\"mailto:someone@example.com?Subject=Hello again\"&gt;Send Mail&lt;/a&gt;&lt;br&gt; &lt;a href=\"javascript:alert('Hello');\"&gt;Javascript&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; target 어트리뷰트타겟 속성은 링크를 클릭했을 때 윈도우를 어떻게 오픈할 지를 지정한다. _self : 링크를 클릭시 연결문서를 현재 윈도우에서 오픈 (기본값)_blank : 링크를 클릭 시 연결문서를 새로운 윈도우나 탭에서 오픈","categories":[],"tags":[]},{"title":"Html5-tag","slug":"Html5-tag","date":"2017-08-06T17:05:16.000Z","updated":"2017-08-06T17:05:16.000Z","comments":true,"path":"2017/08/07/Html5-tag/","link":"","permalink":"https://lsc900427.github.io/2017/08/07/Html5-tag/","excerpt":"","text":"정의문서 형식 정의(Document Type Definition, DTD)태그는 출력할 웹페이지의 형식을 브라우저에게 전달한다.문서의 최상위에 위치해야하며 대소문자를 구별하지 않는다. HTML51&lt;!DOCTYPE html&gt; HTML 4.011&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt; XHTML 1.01&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt; html taghtml 태그는 모든 HTML 요소의 부모 요소이며 웹페이지에 단 하나만 존재한다.즉 모든 요소는 html 요소의 자식 요소이며 html 요소 내부에 기술해야한다 단DTD는 예외이다. html은 글로볼 어트리뷰트를 지원한다. 특히 lang 어트리뷰트를 사용하는 경우가 많다.다음은 한국어를 주언어로 사용하는 경우의 예이다. 1&lt;html lang=\"ko\"&gt; head taghead요소는 메타데이터를 포함하기 위한 요소이며 웹페이지에 단 하나만 존재한다메타데이터는 HTML 문서의 title, style, link, script에 대한 데이터로 화면에 표시되지 않는다.head요소에는 메타데이터 이외의 화면에 표시되는 일체의 요소를 포함시킬 수 없다. title tagtitle요소는 문서의 제목을 정의한다 정의된 제목은 브라우저의 탭에 표시된다. link taglink요소에는 외부 리소스와의 연계 정보를 정의한다 주로 HTML과 외부 CSS 파일을 연계에 사용된다. meta tagmeta 요소는 description, keywords, author, 기타 메타데이터 정의에 사용된다.메타데이터는 브라우저 검색엔진(keywords) 등에 의해 사용된다.charset 어트리뷰트는 브라우저가 사용할 문자셋을 정의한다. description =&gt; 웹페이지의 설명을 정의한다 keywords=&gt; 검색엔진이 사용할 keywords를 정의한다. author=&gt; 저자를 명기한다. 웹페이지를 30초마다 다시시작한다. body tagbody tag는 HTML 문서의 내용을 나타내며 웹페이지에 단 하나만 존재한다. 메타데이터를 제외한 웹페이지를 구성하는 대부분의 요소가 body 요소 내에 기술된다. Text 관련 태그제목 (Headings) 태그heading 태그는 제목을 나타낼 때 사용하며 h1에서 h6까지의 태그가 있다 h1이 가장 중요한 제목을 의미하며 글자의 크기도 가장 크다시맨팅ㄱ 웹의 의미를 살려서 제목 이외에는 사용하지 않는 것이 좋다 검색엔진은 제목 태그를 중요한 의미로 받아들일 가능성이 크다. 12&lt;h1&gt;&lt;/h1&gt;&lt;h2&gt;&lt;/h2&gt; 글자형태의 태그b tagbold체를 지정한다 시맨틱 의미는 없다. i tagitalic체를 지정한다. 의미론적 의미는 없다. em tagemphasized(강조 중요한) text를 지정한다. i tag와 동일하게 italic체로 표현된다 의미론적 중요성의 의미를 갖는다. small tagsmall text를 지정한다. markhighlighted text를 지정한다. deldeleted(removed) text를 지정한다. (가운데 줄) insinserted(added)text를 지정한다. (밑줄) sup / suq tagsub태그는 아래에 쓰인 text sup 태그는 위에 쓰인 text를 지정한다. 본문태그p tag단락을 지정한다 br tagbr은 강제 개행을 지정한다 br tag는 빈요소로 종료 태그가 없다 공백 표시법HTML에서는 1개이상의 공백(space)을 삽입하여 1개의 공백으로 표시된다 1개이상의 연속된 줄바꿈(enter)도 1개의 공백으로 표시된다 연속적 공백을 표시하는 방법은 &amp;nbsp;의 사용 pre형식화된 text를 지정한다 pre태그 내의 content는 작성된 그대로 브라우저에 표시된다. hr수평줄을 삽입한다. q짧은 인용문을 지정한다 브라우저는 인용부호(큰 따옴표)로 q요소를 감싼다. blockquote긴 인용문 블럭을 지정한다. 브라우저는 blockquote 요소를 들여쓰기한다 css를 이용하여 다양한 style을 적용할 수 있다.","categories":[],"tags":[]},{"title":"Html5-sematicWeb","slug":"Html5-sematicWeb","date":"2017-08-06T16:11:41.000Z","updated":"2017-08-06T16:11:41.000Z","comments":true,"path":"2017/08/07/Html5-sematicWeb/","link":"","permalink":"https://lsc900427.github.io/2017/08/07/Html5-sematicWeb/","excerpt":"","text":"정의검색 엔진이라는 것은 매우 중요하다. 웹사이트가 검색엔진에 노출이 되지 않는다면접속자도 없어지기 때문이다.SEO같은 마케팅 도구를 사용하여 본인의 웹사이트를 검색하기 알맞은 구조로웹사이트를 조정하기도 하는데 이는 기본적으로 검색엔진이 웹사이트 정보를 어떻게 수집하는지아는 것으로 부터 시작된다.검색엔진은 로봇이라는 프로그램을 이용해서 매일 전세계의 웹사이트 정보를 수집한다이것을 크롤링이라하면 검색엔진의 크롤러가 이를 수행한다. 그리고 검색 사이트 이용자가검색할 만한 키워드를 미리 예상하여 검색 키워드에 대응하는 인덱스(색인)을 만들어 둔다.(이것을 인덱싱이라 하며 검색엔진의 인덱서가 이를 수행한다.)인덱스를 생성할 때 사용되는 정보는 검색 로봇이 수집한 정보인데 결국 웹사이트의 HTML 코드이다즉 검색엔진은 HTML 코드만으로 그 의미를 인지하여야 하는데 이 때 시맨틱 요소를 해석하게 된다.HTML로 작성된 문서는 컴퓨터가 해석할 수 있는 메타데이터와 사람이 사용하는 자연어 문장이 뒤섞여 있다.아래 코드를 보면 1행 2행은 브라우저에서 동일한 외형을 갖는다. 이는 h1 태그의 디폴트 스타일이 1행과 같기 때문이다. 12&lt;font size =\"6\"&gt;&lt;b&gt;Hello&lt;/b&gt;&lt;/font&gt;&lt;h1&gt;Hello&lt;/h1&gt; 즉 1행의 요소는 의미론 적으로 어떤 의미도 없다. 개발자가 의도한 요소의 의미를 명확히 나타내지 않았고단순히 폰트크기와 볼드체를 지정하는 메타데이터만을 브라우저에게 알리고 있다.그러나 2행은 h1이라는 제목중 가장 상위 레벨이라는 의미를 내포하고 있어서 개발자가 의도한요소의 의미가 명확히 드러나고 있다 이것은 코드의 가독성을 높이고 유지보수를 쉽게한다. 즉 시맨틱 태그란 브라우저 검색엔진 개발자 모두에게 콘텐츠의 의미를 명확히 설명하는 역할을 한다. 시맨틱 태그에 의해 컴퓨터가 HTML요소의 의미를 보다 명확히 해석하고 그 데이터를 활욜ㅇ할 수 있는 시멘틱 웹이 실현될 수 있다 시멘틱 웹이란 웹에 존재하는 수많은 웹페이지들에 메타데이터를 부여하여 기존의 잡다한 데이터 집합이었던 웹페이지를 ‘의미’와 ‘관련성’을가지는 거대한 데이터베이스롤 구축하고자 하는 발상이다. header는 헤더를의미nav는 네비게이션을 의미aside는 사이드에 위치하는 공간을 의미section은 본문의 여러내용을 포함하는 공간을 의미article은 본문의 주내용이 들어가는 공간을 의미footer는 footer를 의미한다.","categories":[],"tags":[]},{"title":"Html5","slug":"Html5","date":"2017-08-06T13:02:06.000Z","updated":"2017-08-06T13:02:06.000Z","comments":true,"path":"2017/08/06/Html5/","link":"","permalink":"https://lsc900427.github.io/2017/08/06/Html5/","excerpt":"","text":"HTML, CSS는 기본이지만 자꾸 그 기본에 대한 불안감이 커져서 총정리 하는 시간을 가져보도록 하려한다. 정의HTML(HyperText Markup Language)는 웹페이지를 기술하기 위한 마크업 언어다.즉 웹페이지의 내용(content)와 구조(structure)를 담당하는 언어로써 HTML 태그를 통해서정보를 구조화하는 것이다. HTML은 그래픽, 통신, 디바이스 접근, 오프라인, 시맨틱 태그, CSS3를 완벽히 지원한다. HTML5문서는 반드시 &lt;!DOCTYPE html&gt;이라는 문서형식을 HTML5로 지정한다.실제 HTML문서는 &lt;html&gt;과 &lt;/html&gt; 사이에 작성한다.&lt;head&gt;와 &lt;/head&gt; 사이에는 document title, 외부파일의 참조, metadata의 설정등이 위치하고이 정보는 브라우저에 표시되지 않는다.웹브라우저에 출력되는 모든 요소들은 &lt;body&gt;태그 안에 위치한다. 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hi&lt;/h1&gt; &lt;h2&gt;Hello&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; HTML document는 .html 확장자를 가지는 순수한 테긋트 파일이다. 그러므로 메모장 등으로도 편집가능하다. 기본문법태그는 대소문자를 구별하지 않으나 소문자를 사용하는 것이 일반적이다. 요소는 중첩될 수 있다. 즉, 요소는 다른 요소를 포함할 수 있는데 이때 부자관계가 성립된다.이런 부자관계로 정보를 구조화 하는 것이다. 이런 중첩된 관계를 시각적으로 파악하기 쉽게 인덴트를 사용한다. 텍스트노드를 가질 수 없는 요소를 빈요소라하는데 빈요소들은 어트리뷰트노드만을 가질 수 있다.br hrimg inputlink meta 어트리뷰트어트리뷰트란 요소의 성질, 특징을 정의하는 명세다. 요소는 어트리뷰트를 가질 수 있으며 어트리뷰트는요소에 추가적인 정보(이미지 파일의 경로, 크기)를 제공한다. 어트리뷰트는 시작태그에 위치해야하고이름과 값의 쌍을 이룬다.1&lt;img src=\"hihi.jpg\"&gt; 이런 정보를 사용해서 브라우저는 img 요소들을 화면에 출력한다. 공용 어트리뷰트공용 어트리뷰트는 모든 요소가 사용할 수 있는 어트리뷰트다.id -&gt; 유일한 식별자를 요소에 지정, 중복지정 불가능class -&gt; 스타일시트에 정의된 class를 요소에 지정 중복지정 가능hidden -&gt; css hidden과 다르게 의미상으로도 브라우저에 노출되지 않게한다.lang -&gt; 지정된 요소의 언어를 지정, 검색엔진의 크롤링시 웹페이지의 언어를 인식할 수 있게 한다.sytle -&gt; 요소에 인라인 스타일을 지정한다.tabindex -&gt; 사용자가 키보드로 페이지를 내비게이션 시 이동 순서를 정한다.title -&gt; 요소에 관한 제목을 지정한다. 주석주석은 개발자에게 코드를 설명하기 위해서 사용되며 브라우저는 주석을 화면에 표시하지 않는다.1&lt;!-- 이 안에 있는 내용은 브라우저에서 안보인다. --&gt;","categories":[],"tags":[]},{"title":"Webpack","slug":"Webpack","date":"2017-08-06T11:44:12.000Z","updated":"2017-08-06T11:44:12.000Z","comments":true,"path":"2017/08/06/Webpack/","link":"","permalink":"https://lsc900427.github.io/2017/08/06/Webpack/","excerpt":"","text":"Webpack는 자바스크립트를 위한 모듈 번들러입니다.많이 쓰이지만 처음 접하면 굉장히 복잡한 도구 중 하나라고 생각합니다.이런 복잡함을 해소하기 위해서 보통 스타터킷으로 많이 시작하곤 하죠.그렇기에 설정들이 무엇을 의미하는지 알기가 쉽지 않습니다.우리는 간단하게 webpack의 설정들이 무엇인지 알아보는 시간을 갖도록 하겠습니다.!! Webpack 설정1단계webpack.config.js파일을 생성합니다.(폴더 생성하셔서 이런 이름의 파일을 만드시면 됩니다) path를 로드합니다. 1const path = require('path'); path의 역할은 경로를 설정해주는 의존 모듈 2단계webpack 설정 모듈을 정의합니다.12345678module.export = &#123; entry: './test2.js', output: &#123; path: __dirname, filename: 'bundle.js', publicPath: 'http://user-server-domain.com/' &#125;,&#125;; 이제 entry와 output이 무엇인지 알아봅시다. entry: 진입 파일의 경로를 설정 output: 출력 파일의 경로를 설정 path: 출력 파일의 폴더를 설정 (절대 경로) / __dirname은 현재 자신의 경로입니다. filename: 출력 파일의 이름 설정 publicPath: 배포시 HTML, CSS 파일 내부의 경로 업데이트를 하기 위한 설정publicPath: HTML, CSS 파일에 경로가 설정되어 있는데 로컬 테스트 환경에서는 로드할 수 있는 URL이 있을 수 있으나 배포시에는 적용이 안되어 일일이 수정해야하는 경우가 있는데그런경우에 사용합니다. 12345678module: &#123; rules: [&#123; test: /\\.js$/, exclude: [ /node_modules/ ], // 제외할 경로 include: [ /src/ ], // 포함할 경로 loader: 'babel-loader' &#125;] &#125;, module: webpack의 모듈을 설정 rules: 다양한 모듈이 있기에 모듈별로 정의해주기 위한 설정 test: 파일 경로를 정규표현식으로 설정 excluee: 제외할 경로(loader가 안 읽을 것들을 제외) include: 포함할 경로(loader가 읽을 것들을 포함) loader: 번들링에 사용되는 모듈을 설정 (css, js, image, babel등 다양한 타입) 1234devtool: 'cheap-module-eval-source-map',resolve: &#123; extensions: ['.js', '.jsx']&#125;, devtool: 번들된 파일에서 오류검출이 아니라 각각의 파일에서 오류를 검출 설정가능(다양한 설정 존) extensions: 파일 확장자 설정 123456plugins: [], devServer: &#123; contentBase: path.join(__dirname, 'dist'), compress: true, port: 9000 &#125; plugins: 결과물인 bundle에 작동하는 추가 node_modules dev-server: 자신이 설정한 포트로 실행되는 개발 서버입니다.서버는 내부적으로 webpack을 호출하며 실시간로딩 및 각종 추가적인 기능을 활용할 수 있습니. contentBase: devServer의 루트 경로를 설정합니다. 3단계이제 웹팩 설정 파일을 보며 복습해 봅시다!12345678910111213141516171819202122232425262728293031323334353637383940414243const path = require('path');module.exports = &#123; entry: path.resolve('src/index.jsx'), output: &#123; path: path.resolve('dist'), filename: 'bundle.js' &#125;, module: &#123; rules: [&#123; test: /\\.jsx?$/, loader: 'eslint-loader', exclude: /node_modules/, enforce: 'pre' &#125;, &#123; test: /\\.jsx?$/, exclude: /node_modules/, loader: 'babel-loader' &#125;, &#123; test: /\\.hbs$/, loader: 'handlebars-loader' &#125;, &#123; test: /\\.css$/, loader: 'style-loader' &#125;, &#123; test: /\\.css$/, loader: 'css-loader' &#125;, &#123; test: /\\.(png|jpg|gif|ttf|eot|woff|woff2|svg)$/, loader: 'url-loader' &#125;] &#125;, devtool: 'cheap-module-eval-source-map', resolve: &#123; extensions: ['.js', '.jsx'] &#125;, plugins: [], devServer: &#123; contentBase: path.join(__dirname, 'dist'), compress: true, port: 9000 &#125;&#125;;","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://lsc900427.github.io/tags/webpack/"},{"name":"v2","slug":"v2","permalink":"https://lsc900427.github.io/tags/v2/"},{"name":"bundler","slug":"bundler","permalink":"https://lsc900427.github.io/tags/bundler/"}]},{"title":"Es6 let,const","slug":"let-const","date":"2017-08-06T11:44:12.000Z","updated":"2017-08-06T11:44:12.000Z","comments":true,"path":"2017/08/06/let-const/","link":"","permalink":"https://lsc900427.github.io/2017/08/06/let-const/","excerpt":"","text":"ES5에서 변수 선언의 유일한 방법 =&gt; var 키워드var 키워드의 특징 Function-level scope 전역 변수의 남용 문제 for문에서 사용한 변수의 전역 참조 문제123456var a = 1;console.log(a); //1&#123; var a = 2; &#125;console.log(a); //2 var 키워드 생략 가능 의도하지 않은 변수의 전역화 변수 호이스팅 인터프리터가 변수를 읽기 전에 undefined값이 할당되는 문제 발생 전역변수가 사용이 편리한 면이 있지만 scope가 넓어서 협업시 변수의 중복 문제 및 재할당문제가 발생 될 수 있다.Es6는 이런 단점을 보완하기 위해서 let, const 키워드를 도입 ES6에서의 변수 letlet의 특징 Block-level scope 123456let a = 1;console.log(a); //1&#123; let a = 2; &#125;console.log(a); //1 중복 선언 금지12345var a = 5;var a = 8; // 가능let b = 10;let b = 12; // 오류발생 호이스팅 자바스크립트는 let, const 포함 모든 선언을 호이스팅한다. var와 let의 차이점은선언문 전에 참조할 경우 undefined가 아닌 Error가 발생한다. TDZ(일시적 사각지대) 때문이다. 123456var c = 1; //의미없console.log(a); // undefinedvar a;console.log(b); // ReferneceErrorlet bar; 이 차이점은 어디서 올까?var로 선언한다면 변수를 선언하고 선언한 변수를 메모리에 넣는초기화 행위(이때 undefined)가 한번에 이뤄진다. 일단 초기화를 하고 변수를 읽는다고 보면 된다.let은 변수가 선언은 되지만 메모리에 넣는 행위(초기화)가변수를 읽는 시점에 이뤄지기 때문에 에러가 발생한다.즉 ReferenceError가 발생하는 이유는 초기화(undefined 할당)가 되지 않고변수만 선언한 시점에서 변수를 불러오기 때문에 에러가 뜨는 것이라고 볼 수 있다.에러가 뜨는 변수등록부터 초기화 될 때까지를 TDZ라 부른다. 전역변수 var는 단순하게 전역에 변수를 때려넣으면 전역 객체의 프로퍼티가 되지만let같은 경우는 전역 변수로 사용해도 전역 객체의 프로퍼티가 아니다. 12345var a = 1;consolelog(window.a); //1let b = 2;console.log(window.b); //undefined const키워드의 특징const는 변하지 않는 값(상수)의 역할을 수행한다.const를 객체의 선언에 사용하면 좋다. 선언과 초기화 let은 초기화 이후 다른 값으로 재할당 가능하나 const는 초기화 이후 재할당이 불가능하다. 또한 선언만 할수 없다.1234const a = 1;a = 2; // Errorconst c; //Error 의미있는 변수는 상수화하자(대문자)1234567if (a &gt; 1) &#123; &#125; // 지양const MIN_NUMBER = 1;if (a &gt; MIN_NUMBER) &#123; &#125; 결론const는 객체타입에 사용하자let은 primirive형 변수에 사용하자ES6는 var를 사용하지말자.","categories":[],"tags":[{"name":"let","slug":"let","permalink":"https://lsc900427.github.io/tags/let/"},{"name":"const","slug":"const","permalink":"https://lsc900427.github.io/tags/const/"}]},{"title":"__proto__","slug":"proto","date":"2017-08-06T11:44:12.000Z","updated":"2017-08-06T11:44:12.000Z","comments":true,"path":"2017/08/06/proto/","link":"","permalink":"https://lsc900427.github.io/2017/08/06/proto/","excerpt":"","text":"ES5에서는 객체 리터럴을 상속하기 위해서 Object.create()란 함수를 사용했다.12345678910var Car = &#123; name: '고급차', do: function() &#123; console.log(this.name +'삽니다.'); &#125;&#125;;var maserati = Object.create(Car);maserati.name = '마세라티';Car.do();maserati.do(); ES6에서는 객체리터럴 내부에서 proto 프로퍼티 직접 설정 가능하다.6123456789101112const Car = &#123; name: &apos;고급차&apos;, do() &#123; console.log(this.name + &apos;삽니다&apos;) &#125;&#125;;const maserati = &#123; name: &apos;마세라티&apos;, __proto__: Car&#125;;Car.do();maserati.do();","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://lsc900427.github.io/tags/ES6/"},{"name":"__proto__","slug":"proto","permalink":"https://lsc900427.github.io/tags/proto/"}]},{"title":"Rest parameter","slug":"rest, spread","date":"2017-08-06T11:44:12.000Z","updated":"2017-08-06T11:44:12.000Z","comments":true,"path":"2017/08/06/rest, spread/","link":"","permalink":"https://lsc900427.github.io/2017/08/06/rest, spread/","excerpt":"","text":"기본 파라미터 초기값123456789function a(x, y) &#123; x = x || 0; y = y || 0; return x + y;&#125;console.log(a()); //0console.log(plus(1,2)); //3 12345function a(x= 0, y=0) &#123; return x + y;&#125;console.log(a());console.log(a(1,2)); Rest Parameter12345function a(...rest) &#123;console.log(Array.isArray(rest));console.log(rest);&#125;a(1,2,3,4,5) Rest 파라미터는 반드시 마지막 파라미터여야 한다. Spread 연산자123456var a = (x, y, z) =&gt; &#123; console.log(x); console.log(y); console.log(z);&#125;a(...[1,2,3]) spread연산자는 인수에 rest는 파라미터에spread 연산자는 순서 상관없이 사용가능하다. 배열로 활용하는 법을 알아보자123456789101112131415161718192021222324252627282930313233343536373839404142// 기존 배열을 새로운 배열로 합칠경우// ES5 var arr = [1,2,3];console.log(arr.concat([4,5,6])); // [1,2,3,4,5,6]//ES6const arr = [1, 2, 3];console.log([...arr, 4, 5, 6]); // [1, 2, 3, 4, 5, 6]//push//ES5var arr1 = [1, 2];var arr2 = [3, 4];Array.prototype.push.apply(arr1, arr2);console.log(arr1); // [1, 2, 3, 4]const arr1 = [1, 2];const arr2 = [3, 4];arr1.push(...arr2); // arr1.push(3, 4);console.log(arr1); //[1, 2, 3, 4];//copy//ES5var arr1 = [1, 2];var arr1copy = arr1.slice();arr1copy.push(3);console.log(arr1copy); // [1, 2, 3];console.log(arr1); // [1, 2];//ES6const arr1 = [1, 2, 3];const arr1copy = [...arr1];arr1copy.push(3);console.log(arr1copy); // [1, 2, 3];console.log(arr1); // [1, 2];","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://lsc900427.github.io/tags/ES6/"},{"name":"rest parameter","slug":"rest-parameter","permalink":"https://lsc900427.github.io/tags/rest-parameter/"},{"name":"spread","slug":"spread","permalink":"https://lsc900427.github.io/tags/spread/"}]},{"title":"ES6-destructuring","slug":"ES6-destructuring","date":"2017-08-06T11:44:12.000Z","updated":"2017-08-06T11:44:12.000Z","comments":true,"path":"2017/08/06/ES6-destructuring/","link":"","permalink":"https://lsc900427.github.io/2017/08/06/ES6-destructuring/","excerpt":"","text":"해체할당(destructuring)은 기존에 구조로 가지고 있던 객체(배열 또는 객체)를 분석하여 개별적인 변수에 할당하는 것배열 또는 객체 리터럴에서 필요한 값만 추출하여 변수에 할당하거나 반환할때 유용 배열 해체할당123456var arr = [1,2];var one = arr[0];var two = arr[1];console.log(one, two) ES6에서 배열해체할당은 배열의 각 요소를 배열로부터 추출하여 변수 리스트에 할당한다.이때 추출, 할당 기준은 인덱스이다. 1234567891011121314151617181920212223//인덱스를 기준으로 배열로부터 요소를 추출하여 변수에 할당한다.const arr = [1, 2];const [hi, hello] = arr;console.log(hi, hello); //1, 2let q, w, e;[q, w] = [1, 2];console.log(q, w); // 1, 2[q, w] = [1]; // 1, undefined[q, w, e = 5] = [1, 2];console.log(q, w, e) // 1, 2, 5[q, ...w] = [1, 2, 3, 4, 5];console.log(q, w) // 1, [2,3,4,5]const arr = [1, 2, 3, 4, 5];const [a, , b] = arr //1, 3 공백이 처리가 안되었다. 객체 해체할당ES5의 경우 배열과 같다. 1234567var ob = &#123;first: 'sang', last: 'lee'&#125;;var name = &#123;&#125;;name.first = ob.first;name.last = ob.last;console.log(name) // &#123;first: 'sang', last: 'lee'&#125; 배열의 해체할당 기준은 index 객체 해체할당의 기준은 key값이다. 1234const ob = &#123;first: 's', last: 'l'&#125;;const &#123;first, last&#125; = ob;console.log(first, last); // s, l 객체 해체할당을 위해서는 = 왼쪽에 객체형태의 변수가 필요하다. 12345678910const &#123;prop1: item1, prop2: item2&#125; = &#123;prop1: 1, prop2: 2&#125;;console.log(&#123;prop1: item1, prop2: item2&#125;); // &#123;prop1: 1, prop2: 2&#125;function padding() &#123; const left = 1, right = 2, top = 3, bottom = 4; return &#123;left, right, top, bottom&#125;;&#125;const &#123;left, bottom&#125; = padding();console.log(left, bottom); // 1, 4","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://lsc900427.github.io/tags/ES6/"},{"name":"desturcturing","slug":"desturcturing","permalink":"https://lsc900427.github.io/tags/desturcturing/"},{"name":"해체할당","slug":"해체할당","permalink":"https://lsc900427.github.io/tags/해체할당/"}]},{"title":"ES6 템플릿 리터럴","slug":"template_literal","date":"2017-08-06T11:44:12.000Z","updated":"2017-08-06T11:44:12.000Z","comments":true,"path":"2017/08/06/template_literal/","link":"","permalink":"https://lsc900427.github.io/2017/08/06/template_literal/","excerpt":"","text":"ES6는 템플릿 리터럴이라 불리는 새로운 문자열 표기법을 도입했다.공백을 표현하기 위해서는 이스케이프 시퀀스를 사용해야한다. 123456const strings =`&lt;li&gt;밥&lt;/li&gt;&lt;li&gt;반찬&lt;/li&gt;&lt;li&gt;고기&lt;/li&gt;`console.log(strings) 문자열 삽입, 표현식에 새로운 방식을 도입했다.${문자열}, ${자바스크립트 표현}123456const first = '이';const last = '지';console.log('정말' + first + last);console.log(`정말$&#123;first&#125;$&#123;last&#125;`);console.log(`$&#123;first === '이'&#125;`)","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://lsc900427.github.io/tags/ES6/"},{"name":"ES2015","slug":"ES2015","permalink":"https://lsc900427.github.io/tags/ES2015/"},{"name":"template-literal","slug":"template-literal","permalink":"https://lsc900427.github.io/tags/template-literal/"}]},{"title":"화살표 함수","slug":"arrow_funtion","date":"2017-08-06T11:44:12.000Z","updated":"2017-08-06T11:44:12.000Z","comments":true,"path":"2017/08/06/arrow_funtion/","link":"","permalink":"https://lsc900427.github.io/2017/08/06/arrow_funtion/","excerpt":"","text":"Syntax 화살표 함수의 호출화살표 함수는 익명함수로만 사용할 수 있다.따라서 호출하기 위해서는 함수표현식을 사용한다. 콜백함수로도 사용할 수 있다. arguments와 rest파라미터arguments 객체는 유사배열 객체이다함수 객체의 arguments 프로퍼티는 객체를 값으로 가지며 함수 내부에서 지역변수처럼 사용된다. Es6는 arguments 프로퍼티가 없기 때문에 rest파라미터를 활용하여 가변인자를 함수내부에 배열로 전달 할 수 있다. thisfunction 키워드를 사용하여 생성한 일반 함수와 Arrow function과의 가장 큰 차이점은 this이다 12345678910111213function Love(she) &#123; this.she = she;&#125;Love.prototype.nice = function (contents) &#123; return contents.map(function (x) &#123; return `$&#123;this.she&#125;는 $&#123;x&#125; 를 사랑합니다` &#125;);&#125;;var people = new Love('그녀');console.log(people.nice(['바람', '물'])); 여기서 this가 생성자 함수의 인스턴스로 기대하였겠지만프로토타입의 처음으로 실행하는 경우의 함수만 인스턴스로 인식이 되고 두번째 부터는 전역함수로 this가 할당이 되기 때문에예상되는 결과가 나오지 않게 된다. 그렇기 때문에 이를 해결하기 위해서4가지 방법이 있다.첫번째는 프로토압의 첫번째 함수에 var that = this; 를대입시켜that.she를 만들어주는 방법이다. 두번째는 function(contents){return contents.map(), this}이후 두번째 인자로 this를 잡아주는 방법이다ㅏ 이는 map의 두번째 인자의 역할 때문이다. 세번째는 bind(this)를 이용하는 것이다. bind 같은 경우는 첫번째 인자가 그 스코프에서의 변수기 때문에 bind(this)를 사용할 경우생성자의 this가 인스턴스인 this로 들어가게 된다. call이 안되는 이유는 call은 호출을 해버리기에 값이 함수가 아니라는 에러가 뜨게 된다.//call이나 apply로 할 수 있는 방법이 있을까? 네번째는 애로우 함수의 this이다 애로우 함수의 this 언제나 자신이 포함된 외부 스코프에서 this를 계승 받는다 즉 this를 생성하지 않고 자신을 포함하는 컨텍스트로부터 this를가져오기 때문에 생성자를 객체를 가져오게 된다. 이로인해서 애로우 함수가 쓰이면 안되는 곳이 있다. 메소드 안에 함수를사용하면 외부의 디스를 가져와서 전역 객체에 바인딩 된다.축약형 표현을 사용해라 yes() {} prototype에 할당하는 경우도 동일한 문제가 발생한다.왜냐면 프로토 타입에도 처음 익명함수는 그 객체이기 때문이다. 애로우함수에서 생성자함수는 아예 존재하지 않는다. 그러므로 애로우 함수는 생성자 함수로 사용 불가능하다. 프로토타입 프로퍼티가 존재하지 않기 때문이다.","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://lsc900427.github.io/tags/ES6/"},{"name":"ES2015","slug":"ES2015","permalink":"https://lsc900427.github.io/tags/ES2015/"},{"name":"Arrow function","slug":"Arrow-function","permalink":"https://lsc900427.github.io/tags/Arrow-function/"},{"name":"this","slug":"this","permalink":"https://lsc900427.github.io/tags/this/"},{"name":"scope","slug":"scope","permalink":"https://lsc900427.github.io/tags/scope/"}]},{"title":"Generator","slug":"Generatore","date":"2017-08-05T15:37:53.000Z","updated":"2017-08-05T15:37:53.000Z","comments":true,"path":"2017/08/06/Generatore/","link":"","permalink":"https://lsc900427.github.io/2017/08/06/Generatore/","excerpt":"","text":"정의Es6에서 도입된 제너레이터는 함수 블록을 한번에 실행하지 않고, 실행을 일시 중지했다가 필요한 시점에다시 시작할 수 있는 함수이다. 제너레이터는 함수이지만 일반 함수와는 다른 독특한 움직임을 한다.함수를 호출하면 함수 블록이 실행되는게 일반적이나제너레이터는 제너레이터 객체를 반환한다.이 제너레이터 객체는 순회 가능한(iterable)한 값이다.즉 제너레이터는 순회가능한 값을 생성하는 함수이다.. 제너레이터 함수의 생성제너레이터는 function* 키워드로 선언한다. 그리고 하나 이상의 yield 구문을 포함한다. 123456function* genFunc() &#123; var index = 0; whild (index &lt; 3) &#123; yield index++ &#125;&#125; 1234567891011121314151617// 제너레이터 함수 선언: 함수 표현식const genFuc = function* () &#123; &#125;;//제너레이터 메소드const obj = &#123; * generatorMethod() &#123; &#125;&#125;;class myClass &#123; *generatorMethod() &#123; &#125;&#125; 제너레이터 함수의 호출제너레이터 함수를 호출하면 함수 블록이 실행되는 것이 아니라, 제너레이터 객체를 반환한다. 1234567891011function* foo() &#123; yield 1; yield 2; yield 3;&#125;const generator = foo();for(const val of generator) &#123; console.log(val);&#125; 12345678910function* genFunc() &#123; console.log('start'); yield 1; console.log('restart'); yield 2; console.log('end');&#125;const generator = genFunc();console.log(generator.next()) 제너레이터 객체는 기본적으로 next()메서드를 가지고 있다 이는 제너레이터 객체가 이터레이터인 것을 의미한다.이터레이터의 next() 메서드는 value, done 프로퍼티를 갖는 객체를 반환한다 value 프로퍼티는 yield 구문이 반환 값이고done 프로퍼티는 제너레이터 함수 내의 모든 yield 구문이 실행되었는지를 나타내는 boolean 타입의 값이다. 이터레이터의 next()와 다르게 제너레이터의 next()는 인자를 받을 수도 있다. 123456789function* foo(n) &#123; const x = yield n; const y = yield (x + 1); const z = yield (y + 2); return x + y + z;&#125;const iterator = foo(1); yield는 대입문 변수에 값을 할당하지 않고 next()의 인자가 대입문 변수에 할당된다.","categories":[],"tags":[{"name":"generator","slug":"generator","permalink":"https://lsc900427.github.io/tags/generator/"}]},{"title":"Symbol","slug":"Symbol","date":"2017-08-05T14:50:07.000Z","updated":"2017-08-05T14:50:07.000Z","comments":true,"path":"2017/08/05/Symbol/","link":"","permalink":"https://lsc900427.github.io/2017/08/05/Symbol/","excerpt":"","text":"심볼은 무엇인가?Symbol이 나오기 전까지 자바스크립트는 6개의 타입을 가지고 있었다. 기본자료형 Boolean null undefined Number String 객체형 Object Symbol은 새롭게 추가된 7번째 타입이다. 애플리케이션 전체에서유일하며 변경불가능한 기본 자료형이다 주로 객체의 키로 사용한다. 심볼의 생성심볼은 Symbol()을 통해 생성한다 생성된 Symbol은 객체가 아닌 값이다. 123let mySymbol = Symbol();console.log(mySymbol);console.log(typeof mySymbol); Symbol() 함수는 String(), Number(), Boolean()과 같이 래퍼 객체를 생성하는 생성자 함수와 달리new 연산자를 사용하지 않는다. 1new Symbol(); // TypeError: Symbol is not a constructor Symbol은 변경 불가능한 기본 자료형이다. 12let mySymbol = Symbol();console.log(mySymbol + 's'); //TypeError: Cannot convert a Symbol value to a string Symbol()함수는 인자로 문자열을 전달 할 수 있다 이 문자열은 Symbol생성에 영향을 주지 않으나생성된 Symbol에 대한 설명으로 디버깅용도로 사용된다. 12let symbolWithDesc = Symbol('ungmo2');console.log(symbolWithDesc); //Symbol(ungmo2) 1234const s1 = Symbol.for('foo');const s2 = Symbol.for('foo');console.log(s1 === s2); Symbol.for 메서드는 인자로 전달받은 프로퍼티 키를 통해 심볼 레지스트리에 존재하는 심볼을 검색해서검색에 성공하면 검색된 심볼을 반환하고 검색에 실패하면 새로운 심볼을 생성한다 심볼() 함수는 매번 새로운 심볼 값을 생성하는 것에 반해 Symbol.for는 단 하나의 Symbol을 생ㅇ성하여 여러 모듈이 공유하게 한다.","categories":[],"tags":[{"name":"generator","slug":"generator","permalink":"https://lsc900427.github.io/tags/generator/"},{"name":"Symbol","slug":"Symbol","permalink":"https://lsc900427.github.io/tags/Symbol/"},{"name":"iterator","slug":"iterator","permalink":"https://lsc900427.github.io/tags/iterator/"}]},{"title":"iteration","slug":"iteration","date":"2017-08-05T14:09:05.000Z","updated":"2017-08-05T14:09:05.000Z","comments":true,"path":"2017/08/05/iteration/","link":"","permalink":"https://lsc900427.github.io/2017/08/05/iteration/","excerpt":"","text":"이터레이션 프로토콜ES6에는 이터러블(iterable)과 이터레이터(iterator)를 정의한 이터레이션 프로토콜iteration protocol)이 추가되었다. iterable : 이터러블은 순회 가능한 자료 구조이다. Symbol.iterator를 key로 사용한 메서드를 구현하는 것에 의해 순회가능한 자료구조인 이터러블이 된다. iterator : 이터러블의 Symbol.iterator를 key로 사용한 메서드는 이터레이터를 반환한다. 이터레이터는 순회 가능한 자료 구조인 이터러블의 요소를탐색하기 위한 포인터로써 next() 메서드를 갖는 객체이다. next() 메서드는 value, done 프로퍼티를 갖는 객체를 반환하며 이 메서드를 통해 이터러블객체를 순회 할 수 있다. iterable 12345678910[symblol.iterator]() ---&gt; 순회가능한 자료구조 iterator &#123; next() &#123; return &#123; value: any, done: boolean &#125;; &#125;&#125; ES6에서 제공하는 빌트인 이터러블은 아래와 같다. Array.prototype[Symbol.iterator]String.prototype[Symbol.iterator]Map.prototype[Symbol.iterator]Set.prototype[Symbol.iterator] DOM data structuresNodeList.prototype[Symbol.iterator]HTMLCollection.prototype[Symbol.iterator] 이터레이션 프로토콜은 이터레이터의 next() 메서드를 통해 다양한 데이터 소스에 순차적으로 접근할 수 있는 일관된 방법을 제시한다. 123const iterable = ['a','b','c'];const iterator = iterable[Symbol.iterator](); 즉 이터레이터를 하면{value: ‘a’, done: false} 라는 형식의 객체가 리턴된다.value는 값을 말하고 done은 있으면 false 없으면 true가 나오는데 이건 왜그럴까? 123456789101112131415for (const val of ['a','b','c']) &#123; console.log(val);&#125;for (const val of 'abc') &#123; console.log(val);&#125;for (const [key, value] of new Map([['a', '1'], ['b', '2'], ['c', '3']])) &#123; console.log(`key : $&#123;key&#125; value : $&#123;value&#125;`)&#125;for (const val of new Set([1,2,3])) &#123; console.log(val);&#125; 피보나치 수열만들어보자 1234567891011121314151617const fibonacci = &#123; [Symbol.iterator]() &#123; let [prev, curr] = [0, 1]; let step = 0; const maxStep = 10; return &#123; next() &#123; [prev, curr] = [curr, prev + curr]; return &#123;value: curr, done: step++ &gt;= maxStep&#125;; &#125; &#125; &#125;&#125;for (const num of fibonacci) &#123; console.log(num);&#125; done이 true가 되면 빠져나오게 된다.","categories":[],"tags":[{"name":"iteration","slug":"iteration","permalink":"https://lsc900427.github.io/tags/iteration/"},{"name":"protocol","slug":"protocol","permalink":"https://lsc900427.github.io/tags/protocol/"}]},{"title":"Promise","slug":"Promise","date":"2017-08-05T13:09:26.000Z","updated":"2017-08-05T13:09:26.000Z","comments":true,"path":"2017/08/05/Promise/","link":"","permalink":"https://lsc900427.github.io/2017/08/05/Promise/","excerpt":"","text":"Promise와 콜백 헬(Callback Hell)자바스크립트에서 빈번히 사용되는 비동기 처리모델은 요청을 병렬로 처리하여다른 요청이 blocking되지 않는 장점이 있지만 단점도 있다.단점은 여러개의 콜백함수가 순서를 보장하기 위해 nesting되어서 복잡도가높아지는 Callback Hell이다. 콜백지옥은 코드의 가독성을 나쁘게 하고 복잡도를 증가시켜 실수를 유발시킬확률이 높아지며 에러 처리가 곤란하다. 12345678try &#123; setTimeout(function()&#123; throw 'Error!'; &#125;, 1000);&#125; catch(e) &#123; console.log('에러를 캐치하지 못해욤'); console.log(e);&#125; Promise의 상태(State)Promise는 비동기 처리가 성공하였는지 또는 실패하였는지 등의 상태 정보를 갖는다. pending : 비동기처리가 아직 수행되지 않은 상태 : resolve 또는 reject함수가 아직 호출되지 않은 상태fulfilled : 비동기 처리가 성공적으로 수행된 상태 : resolve 함수가 호출된 상태rejected : 비동기 처리가 실패한 상태 : reject 함수가 호출된 상태settled : 비동기 처리가 수행된 상태 (성공 또는 실패) : resolve 또는 reject 함수가 호출된 상태 Promise의 생성Promise는 Promise 생성자를 통해 인스턴스화 한다. Promise 생성자는 비동기 작업을 수행할 콜백함수를 인자로 전달 받는데이 콜백함수는 resolve와 reject 콜백함수를 인수로 전달받는다. 12345678var promise = new Promise(function(resolve, reject) &#123;//비동기 작업수행if(/*비동기 작업 수행 성공*/) &#123; resolve('resolved!');&#125; else &#123;/*비동기 작업 수행 실패*/ reject(Error('rejected!'));&#125;&#125;); Promise 생성자가 인자로 전달받은 콜백 함수는 비동기 작업을 수행한다.이 때 비동기 작업이 성공하면 resolve를 호출하고 실패하면 reject를 호출한다. Promise 후속 처리 함수 then, catchPromise 생성자가 인자로 전달받은 콜백 함수에서 비동기 작업(Timer 함수)를 실행해보자.123456789101112131415161718192021//Promise 선언function() asyncFunc(param) &#123; return new Promise(function(resolve,reject) &#123; setTimeout(function() &#123; param ? resolve('resolved!') : reject('rejected!'); &#125;, 2000); &#125;);&#125;;asyncFunc(true).then(function(data) &#123; //resolve가 실행된 경우(성공), resolve 함수에 전달된 값이 data에 저장된다. console.log(data);&#125;, function(reason) &#123; //reject가 실행된 경우(실패), reject 함수에 전달된 값이 reason에 저장 console.log(reason); throw 'Error: ' + reason;&#125;).catch(function(error) &#123; //예외 발생 시 호출된다. console.error(error)&#125;) Promise는 XMLHttpRequest를 순서대로 처리하거나 처리 직후 다른 처리를 해야 할때 유용하게 사용된다.12345678910111213141516171819202122232425262728293031323334353637function get(url) &#123; //promise 생성과 반환 return new Promise(function(resolve, reject) &#123; var xhr = new XMLHttpRequest(); xhr.open('GET', url); xhr.onload = function() &#123; //서버응답 정상이면 if (this.status == 200) &#123; resolve(this.response); &#125; else &#123; //서버의 응답이 비정상 reject(Error(this.statusText)); &#125; &#125;; //네트워크 에러 xhr.onerror = function() &#123; reject(Error('Network Error')); &#125;; xhr.send(); &#125;);&#125;var url = 'http://poiemaweb.com/assets/data/data/json';get(url).then(function(response) &#123; console.log('Success 1', response); return get(url);&#125;).then(function(response) &#123; console.log('Success 2', response); return get(url);&#125;).then(function(response) &#123; console.log('Suceess 3', response); return get(url)&#125;); 중요한 것은 .then(function(){}, function(){})전자성공 후자 실패인데 ,로 같이 써줘야하고 실패한 것이 전송이되면.then()다음번의 then은 성공으로 인식된다. 왜냐면어쩄든 실패한게 돌아왔기 때문 위의 이야기는 return으로 다시 함수를 실행하지 않았을 때고만약 return으로 함수를 실행한다면 이야기가 달라지지 계속 그때 그모습으로실행이 되는거야.그리고 여기선 get(url)을 사용했지만나중엔 get(url) 대신 계속해서 새로운 함수를 집어넣으면개꿀이다. 콜백의 진짜 효능을 볼 수 있겠구나.","categories":[],"tags":[{"name":"Promise","slug":"Promise","permalink":"https://lsc900427.github.io/tags/Promise/"}]},{"title":"Module","slug":"Module","date":"2017-08-05T07:57:01.000Z","updated":"2017-08-05T07:57:01.000Z","comments":true,"path":"2017/08/05/Module/","link":"","permalink":"https://lsc900427.github.io/2017/08/05/Module/","excerpt":"","text":"정의모듈이란 애플리케이션을 구성하는 개별적 요소를 말한다.일반적으로 모듈은 파일 단위로 분리되어 있으며 필요에 따라서 Application은 모듈을 로드한다.모듈은 Application에 분리되어 개별적으로 존재하다 로드시에 Application과 하나가 된다.모듈은 기능별로 분리되어서 작성되므로 개발효율성과 유지보수성의 향상을 기대할 수 있다. 다른 언어들은 #include, import등의 모듈기능을 가지고 있으나 자스는 모듈기능이 없다.스크립트 태그를 이용해서 외부의 스크립트 파일을 가져올 수 있지만 파일마다 독리적인 Scope를가지는 것이 아닌 하나의 전역객체에 바인딩 되기 때문에 전역변수가 중복되는 등의 문제가 발생할 수 있다.이것은 모듈화가 아니다. 자바스크립트가 점점 브라우저에 국한되지 않고 넓게 사용되면서 모듈기능의 구현이 필요해졌다.그 결과 CommonJs와 AMD가 제안되었다. 결과적으로 자바스크립트의 모듈화는 CommonJs와 AMD두가지로 나눠지게 되었고 브라우저에서 모듈을 사용하기 위해서는 둘 중 하나를 구현한 모듈 로더 라이브러리를 사용해야 하는 상황이 되었다. 서버사이드인 Node.js는 사실상 CommonJS를 채택했고 100% 같지 않지만 비슷한 방식을 따르고 있다. 이런 상황에서 ES6는 Client-side에서도 작동하는 모듈기능을 추가하였다. 단 현재의 브라우저들은ES6 모듈기능을 지원하지 않기 때문에 Babel,Typescript, Webpack 등의 트랜스파일러를 사용해야 한다. export &amp; import모듈 안에 선언한 모든 것들은 기본적으로 해당 모듈 안에서만 참조가 가능하다.만약 모들 안에 선언한 항목을 외부에 공개하여 다른 모듈들이 사용할 수 있게 하고 싶다면 export를 해야 한다.선언된 변수, 함수, 클래스 모두 export할 수 있다. 선언문 앞에 export 키워드를 사용한다. 여러개를 export할 수 있는데 이때 각각의 export는 이름으로 구별 가능하다. 123456789101112//lib.jsexport const pi = Math.PI;export function square(x) &#123; return x * x;&#125;export class Person &#123; constructor(name) &#123; this.name = name; &#125;&#125; 한번에 export할 수 도 있다.1234567891011121314//lib.jsexport const pi = Math.PI;export function square(x) &#123; return x * x;&#125;export class Person &#123; constructor(name) &#123; this.name = name; &#125;&#125;export &#123;pi, square, Person&#125;; export된 이름으로 import한다. 1234import &#123;pi, square, Person&#125; from './lib';console.log(pi);console.log(square(10));console.log(new Person('Lee')); 한번에 import 할 수도 있다. 1234import * as lib from './lib'console.log(lib.pi);console.log(lib.square(10));console.log(new lib.Person('Lee')); 이름을 변경하여 import할 수도 있다. 1234import &#123;pi as PI, suare as sq, Person as P&#125; from './lib';console.log(PI);console.log(sq(2));console.log(new P('KIM'));","categories":[],"tags":[{"name":"Module","slug":"Module","permalink":"https://lsc900427.github.io/tags/Module/"},{"name":"Client-side","slug":"Client-side","permalink":"https://lsc900427.github.io/tags/Client-side/"}]},{"title":"draft","slug":"draft","date":"2017-08-05T07:30:46.000Z","updated":"2017-08-05T07:30:46.000Z","comments":true,"path":"2017/08/05/draft/","link":"","permalink":"https://lsc900427.github.io/2017/08/05/draft/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"class와 프로토타입","slug":"class","date":"2017-08-04T12:24:46.000Z","updated":"2017-08-05T07:11:40.000Z","comments":true,"path":"2017/08/04/class/","link":"","permalink":"https://lsc900427.github.io/2017/08/04/class/","excerpt":"","text":"클래스의 정의 클래스는 함수 표현식과 마찬가지로 이름을 가지지 않을 수 있지만 클래스가 할당된 변수를 사용해서 클래스를 생성해야한다.왜냐하면 클래스가 메모리에 선언이 되나 할당된 변수의 이름이 없으면 다시 불러올 수 있는 방법이 없기 때문이다그래서 참조 에러가 뜨게 된다. 인스턴스의 생성new 연산자를 사용하지 않고 인스턴스를 생성하면 에러가 발생한다. constructor 인스턴스를 생성하고 초괴화하기 위한 특수한 메서드다. 클래스 내에 한개만 존재할 수 있으며 2개 이상의 있으면 Error 발생한다. constructor 메서드는 생략 가능하다. 생략하면 constructor() {}를 포함 한것과 동일하다 그러나 객체의 생성과 동시에 초기화하는 것은 불가능하다. 호이스팅 클래스도 let, const와 같이 TDZ가 발생한다.전 게시물에서 말했듯이 선언이 먼저 되고 초기화는 할당시에 동시에 진행되기 때문에 호이스팅이 안되는 것처럼 동작한다. getter, settergetter getter은 일반적으로 어떤 프로퍼티에 접근할 때마다 프로퍼티를 조작하는 행위가 필요할 때에 사용하는 용어다. 612345class Test &#123; constructor( arr = []) &#123; this._arr = arr; &#125;&#125; setter는 프로퍼티에 값을 할당할 때마다 프로퍼티를 조작하기 위해 사용하다getter와 setter전부 ()이 필요없고 값을 할당하면 실행된다61234567891011121314151617 var Foo = (function() &#123; function Foo(prop) &#123; this.prop = prop; &#125; Foo.staticMethod = function() &#123; return &apos;staticMethod&apos;; &#125;; Foo.prototype.prototypeMethod = function() &#123; return &apos;prototypeMethod&apos;; &#125;; return Foo; &#125;)(); var foo = new Foo(123);console.log(Foo.staticMethod()) console.log(foo.prototypeMethod())","categories":[],"tags":[{"name":"class","slug":"class","permalink":"https://lsc900427.github.io/tags/class/"},{"name":"constructor","slug":"constructor","permalink":"https://lsc900427.github.io/tags/constructor/"},{"name":"instance","slug":"instance","permalink":"https://lsc900427.github.io/tags/instance/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-07-30T17:09:07.000Z","updated":"2017-07-30T17:09:07.000Z","comments":true,"path":"2017/07/31/hello-world/","link":"","permalink":"https://lsc900427.github.io/2017/07/31/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: DeploymentTest Link","categories":[],"tags":[]}]}