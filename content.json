{"meta":{"title":"<= 쉽게 읽히는","subtitle":null,"description":null,"author":"SangCheol Lee","url":"https://GITHUB_ID.github.io"},"pages":[{"title":"테스트","date":"2017-08-02T20:29:47.000Z","updated":"2017-08-02T20:29:22.000Z","comments":true,"path":"about/index.html","permalink":"https://GITHUB_ID.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"Es6 let,const","slug":"let-const","date":"2017-08-03T14:08:41.000Z","updated":"2017-08-03T15:31:59.000Z","comments":true,"path":"2017/08/03/let-const/","link":"","permalink":"https://GITHUB_ID.github.io/2017/08/03/let-const/","excerpt":"","text":"ES5에서 변수 선언의 유일한 방법 =&gt; var 키워드var 키워드의 특징 Function-level scope 전역 변수의 남용 문제 for문에서 사용한 변수의 전역 참조 문제123456var a = 1;console.log(a); //1&#123; var a = 2; &#125;console.log(a); //2 var 키워드 생략 가능 의도하지 않은 변수의 전역화 변수 호이스팅 인터프리터가 변수를 읽기 전에 undefined값이 할당되는 문제 발생 전역변수가 사용이 편리한 면이 있지만 scope가 넓어서 협업시 변수의 중복 문제 및 재할당문제가 발생 될 수 있다.Es6는 이런 단점을 보완하기 위해서 let, const 키워드를 도입 ES6에서의 변수 letlet의 특징 Block-level scope 123456let a = 1;console.log(a); //1&#123; let a = 2; &#125;console.log(a); //1 중복 선언 금지12345var a = 5;var a = 8; // 가능let b = 10;let b = 12; // 오류발생 호이스팅 자바스크립트는 let, const 포함 모든 선언을 호이스팅한다. var와 let의 차이점은선언문 전에 참조할 경우 undefined가 아닌 Error가 발생한다. TDZ(일시적 사각지대) 때문이다. 123456var c = 1; //의미없console.log(a); // undefinedvar a;console.log(b); // ReferneceErrorlet bar; 이 차이점은 어디서 올까?var로 선언한다면 변수를 선언하고 선언한 변수를 메모리에 넣는초기화 행위(이때 undefined)가 한번에 이뤄진다. 일단 초기화를 하고 변수를 읽는다고 보면 된다.let은 변수가 선언은 되지만 메모리에 넣는 행위(초기화)가변수를 읽는 시점에 이뤄지기 때문에 에러가 발생한다.즉 ReferenceError가 발생하는 이유는 초기화(undefined 할당)가 되지 않고변수만 선언한 시점에서 변수를 불러오기 때문에 에러가 뜨는 것이라고 볼 수 있다.에러가 뜨는 변수등록부터 초기화 될 때까지를 TDZ라 부른다. 전역변수 var는 단순하게 전역에 변수를 때려넣으면 전역 객체의 프로퍼티가 되지만let같은 경우는 전역 변수로 사용해도 전역 객체의 프로퍼티가 아니다. 12345var a = 1;consolelog(window.a); //1let b = 2;console.log(window.b); //undefined const키워드의 특징const는 변하지 않는 값(상수)의 역할을 수행한다.const를 객체의 선언에 사용하면 좋다. 선언과 초기화 let은 초기화 이후 다른 값으로 재할당 가능하나 const는 초기화 이후 재할당이 불가능하다. 또한 선언만 할수 없다.1234const a = 1;a = 2; // Errorconst c; //Error 의미있는 변수는 상수화하자(대문자)1234567if (a &gt; 1) &#123; &#125; // 지양const MIN_NUMBER = 1;if (a &gt; MIN_NUMBER) &#123; &#125; 결론const는 객체타입에 사용하자let은 primirive형 변수에 사용하자ES6는 var를 사용하지말자.","categories":[],"tags":[]},{"title":"Webpack","slug":"Webpack","date":"2017-08-02T19:42:49.000Z","updated":"2017-08-03T12:39:39.000Z","comments":true,"path":"2017/08/03/Webpack/","link":"","permalink":"https://GITHUB_ID.github.io/2017/08/03/Webpack/","excerpt":"","text":"Webpack는 자바스크립트를 위한 모듈 번들러입니다.많이 쓰이지만 처음 접하면 굉장히 복잡한 도구 중 하나라고 생각합니다.이런 복잡함을 해소하기 위해서 보통 스타터킷으로 많이 시작하곤 하죠.그렇기에 설정들이 무엇을 의미하는지 알기가 쉽지 않습니다.우리는 간단하게 webpack의 설정들이 무엇인지 알아보는 시간을 갖도록 하겠습니다.!! Webpack 설정1단계webpack.config.js파일을 생성합니다.(폴더 생성하셔서 이런 이름의 파일을 만드시면 됩니다) path를 로드합니다. 1const path = require('path'); path의 역할은 경로를 설정해주는 의존 모듈 2단계webpack 설정 모듈을 정의합니다.12345678module.export = &#123; entry: './test2.js', output: &#123; path: __dirname, filename: 'bundle.js', publicPath: 'http://user-server-domain.com/' &#125;,&#125;; 이제 entry와 output이 무엇인지 알아봅시다. entry: 진입 파일의 경로를 설정 output: 출력 파일의 경로를 설정 path: 출력 파일의 폴더를 설정 (절대 경로) / __dirname은 현재 자신의 경로입니다. filename: 출력 파일의 이름 설정 publicPath: 배포시 HTML, CSS 파일 내부의 경로 업데이트를 하기 위한 설정publicPath: HTML, CSS 파일에 경로가 설정되어 있는데 로컬 테스트 환경에서는 로드할 수 있는 URL이 있을 수 있으나 배포시에는 적용이 안되어 일일이 수정해야하는 경우가 있는데그런경우에 사용합니다. 12345678module: &#123; rules: [&#123; test: /\\.js$/, exclude: [ /node_modules/ ], // 제외할 경로 include: [ /src/ ], // 포함할 경로 loader: 'babel-loader' &#125;] &#125;, module: webpack의 모듈을 설정 rules: 다양한 모듈이 있기에 모듈별로 정의해주기 위한 설정 test: 파일 경로를 정규표현식으로 설정 excluee: 제외할 경로(loader가 안 읽을 것들을 제외) include: 포함할 경로(loader가 읽을 것들을 포함) loader: 번들링에 사용되는 모듈을 설정 (css, js, image, babel등 다양한 타입) 1234devtool: 'cheap-module-eval-source-map',resolve: &#123; extensions: ['.js', '.jsx']&#125;, devtool: 번들된 파일에서 오류검출이 아니라 각각의 파일에서 오류를 검출 설정가능(다양한 설정 존) extensions: 파일 확장자 설정 123456plugins: [], devServer: &#123; contentBase: path.join(__dirname, 'dist'), compress: true, port: 9000 &#125; plugins: 결과물인 bundle에 작동하는 추가 node_modules dev-server: 자신이 설정한 포트로 실행되는 개발 서버입니다.서버는 내부적으로 webpack을 호출하며 실시간로딩 및 각종 추가적인 기능을 활용할 수 있습니. contentBase: devServer의 루트 경로를 설정합니다. 3단계이제 웹팩 설정 파일을 보며 복습해 봅시다!12345678910111213141516171819202122232425262728293031323334353637383940414243const path = require('path');module.exports = &#123; entry: path.resolve('src/index.jsx'), output: &#123; path: path.resolve('dist'), filename: 'bundle.js' &#125;, module: &#123; rules: [&#123; test: /\\.jsx?$/, loader: 'eslint-loader', exclude: /node_modules/, enforce: 'pre' &#125;, &#123; test: /\\.jsx?$/, exclude: /node_modules/, loader: 'babel-loader' &#125;, &#123; test: /\\.hbs$/, loader: 'handlebars-loader' &#125;, &#123; test: /\\.css$/, loader: 'style-loader' &#125;, &#123; test: /\\.css$/, loader: 'css-loader' &#125;, &#123; test: /\\.(png|jpg|gif|ttf|eot|woff|woff2|svg)$/, loader: 'url-loader' &#125;] &#125;, devtool: 'cheap-module-eval-source-map', resolve: &#123; extensions: ['.js', '.jsx'] &#125;, plugins: [], devServer: &#123; contentBase: path.join(__dirname, 'dist'), compress: true, port: 9000 &#125;&#125;;","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://GITHUB_ID.github.io/tags/webpack/"},{"name":"v2","slug":"v2","permalink":"https://GITHUB_ID.github.io/tags/v2/"},{"name":"bundler","slug":"bundler","permalink":"https://GITHUB_ID.github.io/tags/bundler/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-07-30T17:09:07.000Z","updated":"2017-07-30T17:09:07.000Z","comments":true,"path":"2017/07/31/hello-world/","link":"","permalink":"https://GITHUB_ID.github.io/2017/07/31/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: DeploymentTest Link","categories":[],"tags":[]}]}