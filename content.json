{"meta":{"title":"<= 쉽게 읽히는","subtitle":null,"description":null,"author":"SangCheol Lee","url":"https://GITHUB_ID.github.io"},"pages":[{"title":"테스트","date":"2017-08-02T20:29:47.000Z","updated":"2017-08-02T20:29:22.000Z","comments":true,"path":"about/index.html","permalink":"https://GITHUB_ID.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"post","slug":"rest, spread","date":"2017-08-03T17:34:26.000Z","updated":"2017-08-04T07:45:15.000Z","comments":true,"path":"2017/08/04/rest, spread/","link":"","permalink":"https://GITHUB_ID.github.io/2017/08/04/rest, spread/","excerpt":"","text":"##기본 파라미터 초기값 123456789function a(x, y) &#123; x = x || 0; y = y || 0; return x + y;&#125;console.log(a()); //0console.log(plus(1,2)); //3 12345function a(x= 0, y=0) &#123; return x + y;&#125;console.log(a());console.log(a(1,2)); Rest Parameter12345function a(...rest) &#123;console.log(Array.isArray(rest));console.log(rest);&#125;a(1,2,3,4,5) Rest 파라미터는 반드시 마지막 파라미터여야 한다. Spread 연산자123456var a = (x, y, z) =&gt; &#123; console.log(x); console.log(y); console.log(z);&#125;a(...[1,2,3]) spread연산자는 인수에 rest는 파라미터에spread 연산자는 순서 상관없이 사용가능하다. ##배열로 활용하는 법을 알아보자 123456789101112131415161718// 기존 배열을 새로운 배열로 합칠경우// ES5 var arr = [1,2,3];console.log(arr.concat([4,5,6])); // [1,2,3,4,5,6]//ES6const arr = [1, 2, 3];console.log([...arr, 4, 5, 6]); // [1, 2, 3, 4, 5, 6]//push//ES5var arr1 = [1, 2];var arr2 = [3, 4];Array.prototype.push.apply(arr1, arr2);console.log(arr1); // [1, 2, 3, 4]","categories":[],"tags":[{"name":"rest parameter,spread, ES6","slug":"rest-parameter-spread-ES6","permalink":"https://GITHUB_ID.github.io/tags/rest-parameter-spread-ES6/"}]},{"title":"화살표 함수","slug":"arrow_funtion","date":"2017-08-03T15:57:12.000Z","updated":"2017-08-04T07:45:15.000Z","comments":true,"path":"2017/08/04/arrow_funtion/","link":"","permalink":"https://GITHUB_ID.github.io/2017/08/04/arrow_funtion/","excerpt":"","text":"Syntax ##화살표 함수의 호출화살표 함수는 익명함수로만 사용할 수 있다.따라서 호출하기 위해서는 함수표현식을 사용한다. 콜백함수로도 사용할 수 있다. arguments와 rest파라미터arguments 객체는 유사배열 객체이다함수 객체의 arguments 프로퍼티는 객체를 값으로 가지며 함수 내부에서 지역변수처럼 사용된다. Es6는 arguments 프로퍼티가 없기 때문에 rest파라미터를 활용하여 가변인자를 함수내부에 배열로 전달 할 수 있다. thisfunction 키워드를 사용하여 생성한 일반 함수와 Arrow function과의 가장 큰 차이점은 this이다 12345678910111213function Prefixer(prefix) &#123; this.prefix = prefix;&#125;Prefixer.prototype.prefixArray = function (arr) &#123; // (A) return arr.map(function (x) &#123; return this.prefix + ' ' + x; // (B) &#125;);&#125;;var pre = new Prefixer('Hi');console.log(pre.prefixArray(['Lee', 'Kim'])); 여기서 this가 생성자 함수의 인스턴스로 기대하였겠지만프로토타입의 처음으로 실행하는 경우의 함수만 인스턴스로 인식이 되고 두번째 부터는 전역함수로 this가 할당이 되기 때문에예상되는 결과가 나오지 않게 된다. 그렇기 때문에 이를 해결하기 위해서4가지 방법이 있다.첫번째는 프로토압의 첫번째 함수에 var that = this; 를대입시켜that.prefix를 만들어주는 방법이다. 두번째는 function(arr){return arr.map(), this}이후 두번째 인자로 this를 잡아주는 방법이다ㅏ 이는 map의 두번째 인자의 역할 때문이다. 세번째는 bind(this)를 이용하는 것이다. bind 같은 경우는 첫번째 인자가 그 스코프에서의 변수기 때문에 bind(this)를 사용할 경우this가 인스턴스인 this가 this로 들어가게 된다. call이 안되는 이유는 call은 호출을 해버리기에 값이 함수가 아니라는 에러가 뜨게 된다. 네번째는 애로우 함수의 this이다 애로우 함수의 this 언제나 자신이 포함된 외부 스코프에서 this를 계승 받는다 즉 this를 생성하지 않고 자신을 포함하는 컨텍스트로부터 this를 계승받는 것이다. 이로인해서 쓰이면 안되는 곳이 있다. 메소드 안에 함수를사용하면 외부의 디스를 가져와서 전역 객체에 바인딩 된다.축약형 표현을 사용해라 () {} prototype에 할당하는 경우도 동일한 문제가 발생한다.왜냐면 프로토 타입에도 처음 익명함수는 그 객체이기 때문이다. 생성자함수는 아예 존재하지 않는다. 그러므로애로우 함수는 생성자 함수로 사용 불가능하다. 프로토타입 프로퍼티가 존재하지 않기 때문이다.","categories":[],"tags":[{"name":"ES6, ES2015, Arrow function, this, scope","slug":"ES6-ES2015-Arrow-function-this-scope","permalink":"https://GITHUB_ID.github.io/tags/ES6-ES2015-Arrow-function-this-scope/"}]},{"title":"ES6 템플릿 리터럴","slug":"template_literal","date":"2017-08-03T15:34:47.000Z","updated":"2017-08-04T07:45:15.000Z","comments":true,"path":"2017/08/04/template_literal/","link":"","permalink":"https://GITHUB_ID.github.io/2017/08/04/template_literal/","excerpt":"","text":"ES6는 템플릿 리터럴이라 불리는 새로운 문자열 표기법을 도입했다.공백을 표현하기 위해서는 이스케이프 시퀀스를 사용해야한다. 123456const strings =`&lt;li&gt;밥&lt;/li&gt;&lt;li&gt;반찬&lt;/li&gt;&lt;li&gt;고기&lt;/li&gt;`console.log(strings) 문자열 삽입, 표현식에 새로운 방식을 도입했다.${문자열}, ${자바스크립트 표현}123456const first = '이';const last = '지';console.log('정말' + first + last);console.log(`정말$&#123;first&#125;$&#123;last&#125;`);console.log(`$&#123;first === '이'&#125;`)","categories":[],"tags":[{"name":"ES2015, ES6, template-literal","slug":"ES2015-ES6-template-literal","permalink":"https://GITHUB_ID.github.io/tags/ES2015-ES6-template-literal/"}]},{"title":"Es6 let,const","slug":"let-const","date":"2017-08-03T14:08:41.000Z","updated":"2017-08-03T15:31:59.000Z","comments":true,"path":"2017/08/03/let-const/","link":"","permalink":"https://GITHUB_ID.github.io/2017/08/03/let-const/","excerpt":"","text":"ES5에서 변수 선언의 유일한 방법 =&gt; var 키워드var 키워드의 특징 Function-level scope 전역 변수의 남용 문제 for문에서 사용한 변수의 전역 참조 문제123456var a = 1;console.log(a); //1&#123; var a = 2; &#125;console.log(a); //2 var 키워드 생략 가능 의도하지 않은 변수의 전역화 변수 호이스팅 인터프리터가 변수를 읽기 전에 undefined값이 할당되는 문제 발생 전역변수가 사용이 편리한 면이 있지만 scope가 넓어서 협업시 변수의 중복 문제 및 재할당문제가 발생 될 수 있다.Es6는 이런 단점을 보완하기 위해서 let, const 키워드를 도입 ES6에서의 변수 letlet의 특징 Block-level scope 123456let a = 1;console.log(a); //1&#123; let a = 2; &#125;console.log(a); //1 중복 선언 금지12345var a = 5;var a = 8; // 가능let b = 10;let b = 12; // 오류발생 호이스팅 자바스크립트는 let, const 포함 모든 선언을 호이스팅한다. var와 let의 차이점은선언문 전에 참조할 경우 undefined가 아닌 Error가 발생한다. TDZ(일시적 사각지대) 때문이다. 123456var c = 1; //의미없console.log(a); // undefinedvar a;console.log(b); // ReferneceErrorlet bar; 이 차이점은 어디서 올까?var로 선언한다면 변수를 선언하고 선언한 변수를 메모리에 넣는초기화 행위(이때 undefined)가 한번에 이뤄진다. 일단 초기화를 하고 변수를 읽는다고 보면 된다.let은 변수가 선언은 되지만 메모리에 넣는 행위(초기화)가변수를 읽는 시점에 이뤄지기 때문에 에러가 발생한다.즉 ReferenceError가 발생하는 이유는 초기화(undefined 할당)가 되지 않고변수만 선언한 시점에서 변수를 불러오기 때문에 에러가 뜨는 것이라고 볼 수 있다.에러가 뜨는 변수등록부터 초기화 될 때까지를 TDZ라 부른다. 전역변수 var는 단순하게 전역에 변수를 때려넣으면 전역 객체의 프로퍼티가 되지만let같은 경우는 전역 변수로 사용해도 전역 객체의 프로퍼티가 아니다. 12345var a = 1;consolelog(window.a); //1let b = 2;console.log(window.b); //undefined const키워드의 특징const는 변하지 않는 값(상수)의 역할을 수행한다.const를 객체의 선언에 사용하면 좋다. 선언과 초기화 let은 초기화 이후 다른 값으로 재할당 가능하나 const는 초기화 이후 재할당이 불가능하다. 또한 선언만 할수 없다.1234const a = 1;a = 2; // Errorconst c; //Error 의미있는 변수는 상수화하자(대문자)1234567if (a &gt; 1) &#123; &#125; // 지양const MIN_NUMBER = 1;if (a &gt; MIN_NUMBER) &#123; &#125; 결론const는 객체타입에 사용하자let은 primirive형 변수에 사용하자ES6는 var를 사용하지말자.","categories":[],"tags":[]},{"title":"Webpack","slug":"Webpack","date":"2017-08-02T19:42:49.000Z","updated":"2017-08-03T12:39:39.000Z","comments":true,"path":"2017/08/03/Webpack/","link":"","permalink":"https://GITHUB_ID.github.io/2017/08/03/Webpack/","excerpt":"","text":"Webpack는 자바스크립트를 위한 모듈 번들러입니다.많이 쓰이지만 처음 접하면 굉장히 복잡한 도구 중 하나라고 생각합니다.이런 복잡함을 해소하기 위해서 보통 스타터킷으로 많이 시작하곤 하죠.그렇기에 설정들이 무엇을 의미하는지 알기가 쉽지 않습니다.우리는 간단하게 webpack의 설정들이 무엇인지 알아보는 시간을 갖도록 하겠습니다.!! Webpack 설정1단계webpack.config.js파일을 생성합니다.(폴더 생성하셔서 이런 이름의 파일을 만드시면 됩니다) path를 로드합니다. 1const path = require('path'); path의 역할은 경로를 설정해주는 의존 모듈 2단계webpack 설정 모듈을 정의합니다.12345678module.export = &#123; entry: './test2.js', output: &#123; path: __dirname, filename: 'bundle.js', publicPath: 'http://user-server-domain.com/' &#125;,&#125;; 이제 entry와 output이 무엇인지 알아봅시다. entry: 진입 파일의 경로를 설정 output: 출력 파일의 경로를 설정 path: 출력 파일의 폴더를 설정 (절대 경로) / __dirname은 현재 자신의 경로입니다. filename: 출력 파일의 이름 설정 publicPath: 배포시 HTML, CSS 파일 내부의 경로 업데이트를 하기 위한 설정publicPath: HTML, CSS 파일에 경로가 설정되어 있는데 로컬 테스트 환경에서는 로드할 수 있는 URL이 있을 수 있으나 배포시에는 적용이 안되어 일일이 수정해야하는 경우가 있는데그런경우에 사용합니다. 12345678module: &#123; rules: [&#123; test: /\\.js$/, exclude: [ /node_modules/ ], // 제외할 경로 include: [ /src/ ], // 포함할 경로 loader: 'babel-loader' &#125;] &#125;, module: webpack의 모듈을 설정 rules: 다양한 모듈이 있기에 모듈별로 정의해주기 위한 설정 test: 파일 경로를 정규표현식으로 설정 excluee: 제외할 경로(loader가 안 읽을 것들을 제외) include: 포함할 경로(loader가 읽을 것들을 포함) loader: 번들링에 사용되는 모듈을 설정 (css, js, image, babel등 다양한 타입) 1234devtool: 'cheap-module-eval-source-map',resolve: &#123; extensions: ['.js', '.jsx']&#125;, devtool: 번들된 파일에서 오류검출이 아니라 각각의 파일에서 오류를 검출 설정가능(다양한 설정 존) extensions: 파일 확장자 설정 123456plugins: [], devServer: &#123; contentBase: path.join(__dirname, 'dist'), compress: true, port: 9000 &#125; plugins: 결과물인 bundle에 작동하는 추가 node_modules dev-server: 자신이 설정한 포트로 실행되는 개발 서버입니다.서버는 내부적으로 webpack을 호출하며 실시간로딩 및 각종 추가적인 기능을 활용할 수 있습니. contentBase: devServer의 루트 경로를 설정합니다. 3단계이제 웹팩 설정 파일을 보며 복습해 봅시다!12345678910111213141516171819202122232425262728293031323334353637383940414243const path = require('path');module.exports = &#123; entry: path.resolve('src/index.jsx'), output: &#123; path: path.resolve('dist'), filename: 'bundle.js' &#125;, module: &#123; rules: [&#123; test: /\\.jsx?$/, loader: 'eslint-loader', exclude: /node_modules/, enforce: 'pre' &#125;, &#123; test: /\\.jsx?$/, exclude: /node_modules/, loader: 'babel-loader' &#125;, &#123; test: /\\.hbs$/, loader: 'handlebars-loader' &#125;, &#123; test: /\\.css$/, loader: 'style-loader' &#125;, &#123; test: /\\.css$/, loader: 'css-loader' &#125;, &#123; test: /\\.(png|jpg|gif|ttf|eot|woff|woff2|svg)$/, loader: 'url-loader' &#125;] &#125;, devtool: 'cheap-module-eval-source-map', resolve: &#123; extensions: ['.js', '.jsx'] &#125;, plugins: [], devServer: &#123; contentBase: path.join(__dirname, 'dist'), compress: true, port: 9000 &#125;&#125;;","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://GITHUB_ID.github.io/tags/webpack/"},{"name":"v2","slug":"v2","permalink":"https://GITHUB_ID.github.io/tags/v2/"},{"name":"bundler","slug":"bundler","permalink":"https://GITHUB_ID.github.io/tags/bundler/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-07-30T17:09:07.000Z","updated":"2017-07-30T17:09:07.000Z","comments":true,"path":"2017/07/31/hello-world/","link":"","permalink":"https://GITHUB_ID.github.io/2017/07/31/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: DeploymentTest Link","categories":[],"tags":[]}]}